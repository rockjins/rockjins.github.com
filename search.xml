<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里云配置 node.js + Nginx 反向代理]]></title>
    <url>%2F2017%2F06%2F14%2F2017-06-15-aliyun-node-nginx%2F</url>
    <content type="text"><![CDATA[学如逆水行舟 1.首先你得安装node.js，我是用nvm安装的，这样比较好控制版本，当然你也可以使用apt-get。 2.下一步是安装Nginx，不去管版本的话，直接sudo apt-get install nginx就行。 3.进入/etc/nginx目录，查看nginx.conf配置文件，在http块中找到这样两句： 12# include /etc/nginx/conf.d/*.conf;# include /etc/nginx/sites-enabled/*; 看看你的这两句有没有注释掉，如果注释了就把#号去掉，没有注释的话就跳过这一步。 4.进入/etc/nginx/conf.d目录，创建我们自己的配置文件，去名规则最好是域名加端口，这样以后方便找，比如我的：rockjins-com-8081.conf，配置文件写入以下内容： 123456789101112131415161718upstream rockjins &#123; server 127.0.0.1:8081; # 这里的端口号写你node.js运行的端口号，也就是要代理的端口号，我的项目跑在8081端口上 keepalive 64;&#125;server &#123; listen 80; #这里的端口号是你要监听的端口号 server_name 39.108.55.xxx www.rockjins.com rockjins.com; # 这里是你的服务器名称，也就是别人访问你服务的ip地址或域名，可以写多个，用空格隔开 location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection &quot;&quot;; proxy_pass http://rockjins; # 这里要和最上面upstream后的应用名一致，可以自定义 &#125;&#125; 5.保存文件后，输入sudo nginx -t测试我们的配置文件是否有错误，一般错误都是漏个分号，少个字母之类的，错误提示很精确，没错的话会输出下面两句: 12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 6.现在我们需要重启Nginx，我们的配置文件才会生效，输入sudo service nginx reload; 7.最后一步把我坑惨了，弄了一晚上，就是安全组的问题，之前有篇文章还写到了这个问题，一转眼就忘了。(ssh连接服务器 Operation timed out) 因为服务跑在8081端口上，但是阿里云的安全组默认是拒绝4000端口以上的授权策略的，大家一定记得去添加安全组规则，如图: 8.打开浏览器，输入你的IP或域名，是不是把8081端口代理到80端口上了，哈哈。 希望这篇文章能够帮到你，有什么问题可以找我，大家一起进步！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[live-server快速搭建服务]]></title>
    <url>%2F2017%2F06%2F14%2F2017-06-14-live-server%2F</url>
    <content type="text"><![CDATA[争取节省大家的时间，看看有多快… 本地开发常常需要搭建临时的服务，第一时间我们会想到用http-server。 但现在流行修改文件浏览器自动刷新，好像叫hot socketing（热拔插），这时候又得用到live-reload。 既然装逼就要装到底，服务启动了，我想浏览器自动打开我的项目，再用个opener。 现在只要使用live-server就能实现这三个插件的所有功能，而且很简单就能启动一个看起来很专业的本地服务。 你只需要全局安装live-server： 1npm install -g live-server 在项目根目录执行这条命令，一般会把它放在package.json的scripts下的server中，然后执行npm run server： 123&quot;scripts&quot;: &#123; &quot;server&quot;: &quot;live-server ./ --port=9090&quot;&#125; 然后你什么也不用做，等待一会浏览器就自动打开，并且当你修改本地任何文件，浏览器都会立即同步。 希望这篇没有任何技术可言的文章能够帮到你！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh连接服务器 Operation timed out]]></title>
    <url>%2F2017%2F05%2F27%2F2017-05-27-service-port%2F</url>
    <content type="text"><![CDATA[买了个阿里云ECS云服务器，捣鼓吧… 大家知道，云服务器的默认端口是22，为了防止服务器端口被轻易扫描到，我在sshd_config中把Port改为3999（这是我随意改的一个端口号）。 今天再次进行ssh连接时，登了大概一分钟，报了这样一个错: ssh: connect to host 39.108.55.** port 3999: Operation timed out 连接服务器超时了，第一时间我想到服务器被墙了，不过我在阿里云上买的，没道理啊，先去ping一下再说: 没被墙啊，去google下，又说是本地防火墙把端口禁了，打开防火墙一看： 也不是防火墙的问题啊，行吧，跑到阿里云去看看，东找西找，来到了安全组规则栏目下，长这个样: 上面有个端口范围，我发现自己随便设置的3999并不在配置的范围里，遂添加了一条安全组规则，把3999端口加了上去，再进行ssh连接，终于连上了… 这问题弄了我一上午，菜鸟就是苦，啥都自己摸索，坚持吧！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Service</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[昨夜の梦 - 树]]></title>
    <url>%2F2017%2F05%2F24%2F2017-05-24-diary-tree-die%2F</url>
    <content type="text"><![CDATA[还是这个熟悉的地方，一片迷雾，看不清周围的环境。 在这片荒芜的土地上有一棵孤独的小树苗，大概到我腰间的高度，相比它的粗细来说已经算是高挑的了。 树枝被一根粗麻绳绑着，麻绳的另一头绑在我的脖子上。 我站在一旁，手里拿着一根不知哪来的水管，不时给小树苗浇浇水，渴了就自己喝一口，我似乎从未如此惬意、满足。 小树长得很快，不一会就和我一样高了，我就像看自己孩子长大一样幸福，唯一不足就是绳子勒的有点紧。 时间过的很快，我想如果继续这样下去，我会不会被吊死在这。 我试着松一松颈上的绳子，才发现是死结，树上绑的也是死结。 其实我可以把这棵树连根拔起，但我舍不得，这是目光可及的唯一一棵树。 又过了一会，树干已经和我一样粗了，要拔起来已经不可能了，我恳求它不要再长高了，我害怕死了。 待续… 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见音乐相关中英文速查表（持续更新）]]></title>
    <url>%2F2017%2F05%2F23%2F2017-05-23-music-english-chinese%2F</url>
    <content type="text"><![CDATA[叫你不好好学英语 A 英文 中文 备注 Analog 模拟(信号) 传输感很差 Acoustic 原生 相比处理过的音色而言 Acoustic Guitar 木吉他 AUX 辅助 AFL 推子后监听 Activity 动态 B 英文 中文 备注 Bass 低音、贝斯 Bpm 速度、拍子 Beat Per Minute(每分钟拍子数) Bar 小节 Breakdown =&gt; 歌曲中夹杂着的具有“切断感”的伴奏 Birdge Plot 桥段 用于衔接歌曲段落 Brass 铜号 泛指铜乐器 Bell 金属铃 BAL/Balance 平衡 C 英文 中文 备注 Chord 和弦 Chorus 合唱 Chime 风铃 Clip 削波 Cue 监听、选听 D 英文 中文 备注 Digital 数字(信号) 这个概念被放大化并推广，当然，这也是一场技术革命 Delay 延迟 Drums 鼓 Drumstick 鼓棒 Display 显示 Dynamic 动态 E 英文 中文 备注 EFF/Effects 效果 一般针对音频信号 Equalize 均衡 Export 导出 EP 电钢琴 Electric Piano Electric Guitar 电吉他 Echo 回声 F 英文 中文 备注 Fade 过渡(音频) 常见的有：Fade In（淡入）、Fade Out（淡出）、Cross Fade（音频交叉过渡） Flute 笛子 FX 特效 Fuse 保险 FT Switch 脚踏开关 G 英文 中文 备注 Groove =&gt; 鼓各个元素之间的搭配和切换（节奏律动，和loop有相通的地方） Gain 增益 控制输入信号的大小 Group 组 H 英文 中文 备注 Horn 号 泛指喇叭状的乐器 High 高音 I 英文 中文 备注 Instrument 乐器 Import 导入 Intro 开头 歌曲的开头 Insert 插入 J 英文 中文 备注 K 英文 中文 备注 Keys 键盘(钢琴) L 英文 中文 备注 Loop 循环 Low 低音 L/Left 左声道 Limit 限幅 Lamp 灯 Level 电平 M 英文 中文 备注 Metronome 节拍器 Melody 旋律 Mix 混音 Mixer 混音器 音频缩混中的一个重要设备（设置），Cubase里按F3，可出现Mixer面板（硬/软） Mix down 音频缩混 每个音频轨之间的关系和比例的调整 MID/Middle 中音 MON/Monitor 监听 Master 总路输出 Main 总 MONO 单声道 Modulation 移调 N 英文 中文 备注 Note 音符、音调 口语把乐谱也叫做Note O 英文 中文 备注 Outro 结尾 歌曲的结尾(Ending) Orch 交响类音色 Orchestra Organ 风琴 P 英文 中文 备注 Pitch 音高 Pan 声像定位 Pan与Phase的区别 Phase 相位 Percussion 打击乐 Piano 钢琴 Plucked 弹拨乐 Pad 插入衰减 PFL 推子前监听 Phantom 幻象 Progressor 处理器 Q 英文 中文 备注 Quantize 量化 即将手动输入的midi音符按照规定精度（1/4拍，1/8拍，1/16拍）对位到精确的拍子中，一般节奏类乐器多需要量化功能，但过于依赖此功能容易导致音乐过于死板（如钢琴，管乐，并不提倡使用此功能） R 英文 中文 备注 REV/Reverb 混响 使音频更有空间感，有的时候可以让死板的声音变得更真实，震撼 Rhythm 节奏 R/Right 右声道 RET/RTN/Return 返回 S 英文 中文 备注 Synth 合成 Synthesizer 合成器(硬/软) 一般指创造音色的软件或硬件 Sampling 采样 截取音频文件中的某部分然后把它取出来独立作成一个文件 Strings 弦乐类音色 Sub 超低音 Sax 萨克斯 Saxophone Sensitivity 敏感度 控制输入信息大小 Signal 信号 Sum 总 Stereo 立体声 Sustain 维持 相当于延音 Scoop 消减中音 T 英文 中文 备注 Tempo 速度、拍子 Tick 拍 Track 轨道 比如Audio Track(音频轨)、MIDI Track(MIDI轨)… Trim 增益 控制输入信号大小 Tremble 比High更高的高音 U 英文 中文 备注 UNBLA/Unbalance 非平衡 V 英文 中文 备注 Volumn 音量 Violin 小提琴 Voice/Vocal 人声 W 英文 中文 备注 Wave wave文件格式 最常用的原始音频文件格式，保留着音频的最棒效果和质量 Wind 笛子和单簧管 Woodwind 木笛、竹笛 Woofer 低音 X 英文 中文 备注 Y 英文 中文 备注 Z 英文 中文 备注 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postMessage死循环与window.parent]]></title>
    <url>%2F2017%2F05%2F19%2F2017-05-19-iframe-parent%2F</url>
    <content type="text"><![CDATA[轮回不止 生死不休 上礼拜用postMessage进行iframe跨域通信(使用postMessage解决iframe跨域通信问题），因为写的代码不够健壮，其实说到底还是了解的知识点不够多，这个礼拜BUG就提上来了… 我相当于开发一个中间层框架，在我外层有一个大框架用iframe包着我，我再用iframe包着另一个页面，如图（配色好评）： 按理说用postMessage是不会出问题的:我负责父页面和子页面之间的通信，他们把数据发送给我，我再替他们发送给对方。 但是这几个框架又是相互独立的，只有在特定的情景下才会这样嵌套，BUG就是在页面独立时出现的。 我们知道，获取父级iframe最简单的方法就是window.parent，这样可以拿到父级iframe的window对象，我大概就是这样发送postMessage给父级iframe的： parent.postMessage(&#39;someMessage&#39;, &#39;*&#39;) 而且postMessage方法的调用是写在onmessage事件里的，也就是子页面发送消息过来，我监听到onmessage事件，就发送消息给父级iframe。 问题来了，之前说过框架之前都可以独立运行，如果没有父级iframe，只剩下我的框架和子框架，会发生什么呢？ 大家来开心一下，就是这样子： 而且最诡异的一点是，信息发起人的HOST并不是子页面,而是我自己？WTF? 我不信，跑去找子页面的开发负责人，问他是不是写了死循环不停发消息，对方很坦荡的把代码打开：“你自己看吧，哪来的死循环？” 好吧，回去自己找BUG，经过一个小时的埋头苦读，终于发现了问题所在。 我现在问大家一个问题：当你的页面处于最顶层，也就是外层没有iframe包裹你，求这时window === window.parent的返回值。 呵呵，居然是true，也就是说，当你的页面处于最顶层，window.parent指向你自己！ 有图为证： 相当于当你处于最顶层时，你儿子就是你自己，你也可以是自己的爷爷，当然也可以是自己的曾孙，大概就是这个意思，希望大家以后不会遇到这个坑，其实也不算坑啦，说到底还是自己知识面不够广，连轮回这么简单的道理都不明白… 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何兼容多种模块规范]]></title>
    <url>%2F2017%2F05%2F09%2F2017-05-09-compatible-module%2F</url>
    <content type="text"><![CDATA[如果你也在开发模块，并且想让你的模块同时在前后端运行，那么这篇文章会让你有收获。 模块运行的环境主要有四个: Node 、 AMD 、CMD 、 普通的浏览器环境 要同时兼容这四种环境，我们只需要找出每个环境独有的特点即可进行判断： 1234567891011121314151617181920212223242526;(function (name, definition) &#123; // 检测上下文环境是否为AMD、CMD var hasDefine = typeof define === 'function', // 检查上下文环境是否为Node hasExports = typeof module !== 'undefined' &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境、CMD环境则define(definition); define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); module.exports = definition(); &#125; else &#123; // 将模块的执行结果赋值在window变量中，在浏览器中this等于window对象，this[name] = definition(); this[name] = definition(); &#125;&#125;)('hello', function () &#123; var hello = function () &#123;&#125;; return hello;&#125;); 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Module</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用postMessage解决iframe跨域通信问题]]></title>
    <url>%2F2017%2F05%2F05%2F2017-05-05-iframe-cross-domain-Communication%2F</url>
    <content type="text"><![CDATA[这周碰到一个让人头疼的需求：要在我的web项目中嵌入另一个第三方web项目。第一时间想到的就是用iframe了，但问题来了，我和第三方web项目是有交互的，这就违反同源策略了，处理跨域问题是最让人头疼的事之一。 需求是这样的，在我的页面点击一些按钮，要实时反馈到iframe子页面，子页面再进行响应。 当时脑子里第一时间想到的解决方案是：用NGINX把两个项目代理到同一域名下。但这样似乎有点小题大做了，有没有更方便快捷的方法呢？ 在window对象下有个postMessage方法，是专门用来解决跨域通信问题的。 关于postMessage的详细介绍请戳这里，不过MDN的文档太详细了，导致有些同学看完还是一脸懵逼，下面我们就来看看怎么用postMessage实现iframe跨域通信，当你会用了之后再回去看文档，感觉是完全不同的。 首先我们模拟场景，假设有两个不同源的页面，iframePage.html是index.html的子页面： 123456789&lt;!-- index.html --&gt;&lt;body style="border:5px solid #333;"&gt; &lt;h1&gt;this is index&lt;/h1&gt; &lt;iframe src="./iframePage.html" id='myframe'&gt;&lt;/iframe&gt;&lt;/body&gt; 1234567&lt;!-- iframePage --&gt;&lt;body style="border:5px solid #333;"&gt; &lt;h1&gt;this is iframePage&lt;/h1&gt;&lt;/body&gt; 现在这两个iframe是无法通信，因为它们是不同源的（假设存在跨域问题），这时候就要用到postMessage了。 我们先试着从父页面向子页面发送一条消息： 123456789101112// idnex.html//获取iframe元素iFrame = document.getElementById('myframe')//iframe加载完毕后再发送消息，否则子页面接收不到messageiFrame.onload = function()&#123; //iframe加载完立即发送一条消息 iFrame.contentWindow.postMessage('MessageFromIndex1','*');&#125; 我们知道postMessage是挂载在window对象上的，所以等iframe加载完毕后，用iFrame.contentWindow获取到iframe的window对象，然后调用postMessage方法，相当于给子页面发送了一条消息。 postMessage方法第一个参数是要发送的数据，可以是任何原始类型的数据。 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)之前，第一个参数必须是一个字符串。 postMessage方法第二个参数可以设置要发送到哪个url，如果当前子页面的url和设置的不一致，则会发送失败，我们设置为*，代表所有url都允许发送。 postMessage方法还有第三个参数，属于高级用法，这里不做讨论，可以稍后去MDN了解。 消息发送到iframePage.html，我们来接收message： 123456789// iframePage.html//回调函数function receiveMessageFromIndex ( event ) &#123; console.log( 'receiveMessageFromIndex', event )&#125;//监听message事件window.addEventListener("message", receiveMessageFromIndex, false); 我们只需要在子页面监听message事件，并且设置好回调函数即可，来看看打印出来的event： event对象中的data属性存放着我们从父页面传过来的数据，就这么简单！ 让我们再试试从子页面发送数据给父页面： 1234// iframePage.html//给父页面发送消息，data为对象parent.postMessage( &#123;msg: 'MessageFromIframePage'&#125;, '*'); 父页面接收数据： 123456789//index.html//回调函数function receiveMessageFromIframePage (event) &#123; console.log('receiveMessageFromIframePage', event)&#125;//监听message事件window.addEventListener("message", receiveMessageFromIframePage, false); 我看看到，的确可以传输不同的数据，此时data为一个对象： 大家可以到postMessage-demo把代码clone下来运行试试看。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>iframe</tag>
        <tag>Cross-Domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meteor: Error: Depending on unknown package xxx]]></title>
    <url>%2F2017%2F04%2F12%2F2017-04-12-meteor-unknow-package%2F</url>
    <content type="text"><![CDATA[Versions: 1.4.1 据我在GitHub issue上了解到的，许多人都碰到这个问题。 很多朋友程序运行时没问题，但build的时候就出现这个错误，我是这样解决的： Meteor build 时找不到新添加的包解决办法： 1.执行Meteor reset； 2.删除.meteor/local/resolver-result-cache.json文件； 这个文件包含所有package的缓存，在运行meteor build时，打包命令运行后会去读这个文件，但新添加的package并不在其中，所以会出现找不到新添加的package的问题。删除这个文件后，再次执行打包命令，程序发现找不到这个缓存文件，就会去重新读取所有的package，这时候就不存在找不到新添加的package的问题了。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Meteor</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』METEOR教程(REACT VERSION)]]></title>
    <url>%2F2017%2F04%2F05%2F2017-04-05-meteor-react-todo-app%2F</url>
    <content type="text"><![CDATA[Read the original 如果你有成为全栈的梦想，METEOR是个不错的平台。 1.创建你的第一个App(Creating your first app)在这个教程中，我们会创建一个简单的App去管理待办事项列表并和他人合作完成任务。在完成这个项目后，你会对Meteor和它的项目结构有个基本的了解，。我们先创建App，打开命令行，键入以下命令： 译者注：前提是你安装了meteor,具体安装步骤可以参考这里 1meteor create simple-todos 它会创建一个名叫simple-todos的文件夹，里面包含我们开发meteor App所需要的文件: 1234567client/main.js # 在客户端的JavaScript入口文件client/main.html # 定义视图容器client/main.css # 定义App样式server/main.js # 服务端的JavaScript入口文件package.json # 用于安装和管理NPM包.meteor # Meteor内部文件.gitignore # git的管理文件 运行这个新创建的App： 123cd simple-todosmeteor npm installmeteor 打开你的浏览器并输入http://localhost:3000查看App是否运行成功。 在我们教程正式开始之前，你可以看看这个App的内部组成。比如，用你惯用的编辑器修改client/main.html文件中的&lt;h1&gt;内的文字。当你修改完毕保存文件时，浏览器会自动更新并展示新的内容，我们叫它热拔插(hot code push)。 ES2015特性如果你还没有尝试过下个版本的JavaScript特性，初始App内的代码语法，还有整个教程使用的语法，都会让你感到怪异。这是因为Meteor支持大部分ES2015的特性，也就是下个版本的JavaScript。常用的特性包括： 箭头函数：(arg) =&gt; {return result;} 简写方法：render() { ... } const和let取代var 你可以在ecmascript docs查看Meteor支持的新特性。更多关于ES2015的信息可以查看下面几篇文章： Luke Hoban’s “ES6 features” Kyle Simpson’s “You don’t know JS: ES6 and beyond” Nikolas C. Zakas “Understanding ECMAScript 6” 现在你有一些如何开发Meteor App的经验了，让我们开始创建一个待办事项列表应用程序吧！如果你在这个教程中发现了bug或是错误，可以在GitHub上请发起issue或PR。 2.使用React Components定义视图层(Defining views with React components)我们把React作为视图层，让我们增加一些NPM packages，以便使用React进行开发。打开一个新的terminal在你的App根目录下，键入以下命令： 1meteor npm install --save react react-dom 替换初始化的代码在开始前，我们要替换App的初始代码。接下来我们讨论要做些什么。 第一步，替换初始化的HTML中的内容： 1234567&lt;head&gt; &lt;title&gt;Todo List&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="render-target"&gt;&lt;/div&gt;&lt;/body&gt; 第二步，删除client/main.js，并创建三个新文件： 1234567891011// ./client/main.jsximport React from 'react';import &#123; Meteor &#125; from 'meteor/meteor';import &#123; render &#125; from 'react-dom';import App from './imports/ui/App.jsx';Meteor.startup(() =&gt; &#123; render(&lt;App /&gt;, document.getElementById('render-target'));&#125;) 123456789101112131415161718192021222324252627282930313233343536// ./imports/ui/App.jsximport Reacr, &#123; Component &#125; from 'react';import Task from './Task.jsx';//App组件 —— 代表整个Appexport default class App extends Component &#123; getTasks() &#123; return [ &#123; _id: 1, text: 'This is task 1' &#125;, &#123; _id: 2, text: 'This is task 2' &#125;, &#123; _id: 3, text: 'This is task 3' &#125;, ]; &#125; renderTasks()&#123; return this.getTasks().map.((task) =&gt; &#123; &lt;Task key=&#123;task._id&#125; task=&#123;task&#125; /&gt; &#125;); &#125; render()&#123; return ( &lt;div className="container"&gt; &lt;header&gt; &lt;h1&gt;Todo List&lt;/h1&gt; &lt;/header&gt; &lt;ul&gt; &#123;this.renderTasks()&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; 123456789101112131415161718// ./imports/ui/Task.jsximport React, &#123;Component, PropTypes&#125; from 'react';// Task组件 —— 代表一个单独的todo条目export default class Task extends Component &#123; render()&#123; return ( &lt;li&gt;&#123;this.props.task.text&#125;&lt;/li&gt; ); &#125;&#125;Task.propTypes = &#123; //这个组件通过React prop去得到并显示任务 //我们可以用propTypes去指明哪些是必须的 task:PropTypes.object.isRequired,&#125; 我们仅在我们的App中做了3件事： 一个App React component 一个Task React component 一些初始化代码(在client/main.jsx客户端JavaScript入口文件中)，在Meteor.startup代码块中，我们知道当页面加载完毕后会执行里面的代码。这段代码加载其他组件，并渲染#render-target元素。 你还可以在Application Structure article中了解import是如何工作的，还有如何组织你的代码。 在接下来的教程中，我们增加或更改代码，都会涉及到这些组件。 检查结果在浏览器中，我们的app应该看起来像这个样子： Todo List This is task 1 This is task 2 This is task 3 如果你的app看起来不是这样，可以去GitHub下载代码，并和你自己的代码对比，找出不同的地方。 HTML文件定义静态内容Meteor会解析你app目录下的所有HTML文件，并识别三个顶级标签&lt;head&gt;,&lt;body&gt;和&lt;template&gt;。&lt;head&gt;标签内的所有内容会发送到客户端HTML的head标签，&lt;body&gt;标签内的所有内容也会发送到客户端HTML的body标签内，就和正常的HTML文件一样。 任何&lt;template&gt;标签内的内容会编译成Meteor Templates，你可以在HTML中用{{>templateName}}去调用，或在JavaScript中用Template.templateName去调用。在这个教程中，我们不会用到Meteor提供的模板特性，因为我们将用React去定义所有视图组件。 用React定义视图组件在React中，视图组件是React.Component的子类(当我们用import { Component } from &#39;react&#39;的方式引入时)。你可以自由的在组件上添加方法，但有几个特殊的方法是不行的，比如render方法。组件通过其父组件的props属性，也可以接收数据。在这个教程中，我们会重温一些React的通用特性。你也可以查看React官方教程。 重新审视JSX中的render方法在每个React Component中最重要的方法就是render()，它会访问React并得到被描述的HTML，然后把组件显示出来。这个HTML内容用JavaScript扩展语法写成，叫JSX,看起来就像在JavaScript中写HTML。你可以看到一些显而易见的差异：在JSX中，你要用className去代替class属性。还有一件很重要的事，它不是像Spacebars和Angular一样的模板语言，实际上它是直接编译成正常的JavaScript。查看更多JSX的信息。 JSX支持ecmascript扩展包，所以它默认支持所有Meteor app的扩展包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*./client/main.css*/body &#123; font-family: sans-serif; background-color: #315481; background-image: linear-gradient(to bottom, #315481, #918e82 100%); background-attachment: fixed; position: absolute; top: 0; bottom: 0; left: 0; right: 0; padding: 0; margin: 0; font-size: 14px;&#125;.container &#123; max-width: 600px; margin: 0 auto; min-height: 100%; background: white;&#125;header &#123; background: #d2edf4; background-image: linear-gradient(to bottom, #d0edf5, #e1e5f0 100%); padding: 20px 15px 15px 15px; position: relative;&#125;#login-buttons &#123; display: block;&#125;h1 &#123; font-size: 1.5em; margin: 0; margin-bottom: 10px; display: inline-block; margin-right: 1em;&#125;form &#123; margin-top: 10px; margin-bottom: -10px; position: relative;&#125;.new-task input &#123; box-sizing: border-box; padding: 10px 0; background: transparent; border: none; width: 100%; padding-right: 80px; font-size: 1em;&#125;.new-task input:focus&#123; outline: 0;&#125;ul &#123; margin: 0; padding: 0; background: white;&#125;.delete &#123; float: right; font-weight: bold; background: none; font-size: 1em; border: none; position: relative;&#125;li &#123; position: relative; list-style: none; padding: 15px; border-bottom: #eee solid 1px;&#125;li .text &#123; margin-left: 10px;&#125;li.checked &#123; color: #888;&#125;li.checked .text &#123; text-decoration: line-through;&#125;li.private &#123; background: #eee; border-color: #ddd;&#125;header .hide-completed &#123; float: right;&#125;.toggle-private &#123; margin-left: 5px;&#125;@media (max-width: 600px) &#123; li &#123; padding: 12px 15px; &#125; .search &#123; width: 150px; clear: both; &#125; .new-task input &#123; padding-bottom: 5px; &#125;&#125; 增加上面的CSS代码到你的项目中，这个首页看起来会很棒。在你的浏览器中检查样式是否加载进去了。 3.在集合中储存任务(Storing tasks in a collection)Meteor使用集合(collections)储存持久化数据。在Meteor中，集合的特殊之处在于，可以同时在服务端和客户端读取数据，这让我们很容易编写视图层逻辑，而不需要编写太多服务端代码。集合会自动更新自身，所以一个视图组件配合集合，可以自动的显示最新的数据。 你可以在Meteor教程中阅读更多有关集合的文章。 创建一个集合很简单，只需要在你的代码中调用MyCollection = new Mongo.Collection(&quot;my-collection&quot;);。在服务端，这会创建一个名叫my-collection的MongoDB集合，它会创建一个缓存去链接服务端的集合。我们将在第12章节了解更多客户端和服务端的区别，我们假设整个数据库都运行在客户端，并开始编写我们的代码。 我们创建一个Mongo集合来定义新的tasks模块，并导出它： 1234//imports/api/tasks.jsimport &#123; Mongo &#125; from 'meteor/mongo';export const Tasks = new Mongo.Collection('tasks'); 注意，我们把这个文件放在了新的目录imports/api下。这是一个合适的位置，用于放置和API有关的文件。我们在这里抛出”collections”，之后读取它并添加一个”publications”，再用”methods”去编辑它。你可以在Meteor指南中了解更多有关如何在APP中组织你的代码结构。 我们需要在服务端导入这个模块（这将创建MongoDB集合，并设置管道得到数据给Client）： 12//server/main.jsimport '../imports/api/tasks.js'; 在React component中使用集合数据我们使用Atmosphere包:react-meteor-data，它会创建一个数据容器，把Meteor的响应式数据供给给React component。 我们要安装一个Meteor包，以及它要使用到的NPM包，react-addons-pure-render-mixin： 12meteor npm install --save react-addons-pure-render-mixinmeteor add react-meteor-data 在使用react-meteor-data前，我们需要使用createContainer高阶组件把我们的组件包裹在一个容器中： 12345678910111213141516171819202122232425262728293031323334353637383940//imports/ui/App.jsximport React, &#123; Component, PropTypes &#125; from 'react';import &#123; createContainer &#125; from 'meteor/react-meteor-data';import &#123; Tasks &#125; from '../api/tasks.js';import Task from './Task.jsx';//App容器 - 代表整个Appclass App extends Component &#123; renderTasks() &#123; return this.props.tasks.map((task) =&gt; ( &lt;Task key=&#123;task._id&#125; task=&#123;task&#125; /&gt; )); &#125; render() &#123; return ( &lt;div className="container"&gt; &lt;header&gt; &lt;h1&gt;Todo List&lt;/h1&gt; &lt;/header&gt; &lt;ul&gt; &#123;this.renderTasks()&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;App.propTypes = &#123; tasks: PropTypes.array.isRequired,&#125;;export default createContainer(() =&gt; &#123; return &#123; tasks: Tasks.find(&#123;&#125;).fetch(), &#125;;&#125;, App); 这个被包裹的App组件从Tasks集合中提取tasks，并将它们用作App底层组件，它们被包装为tasks prop。它以响应的方式运行，当数据库内容改变，App会重新渲染，我们可以立刻看到！ 当你对代码进行以上更改时，你会发现之前在代办列表中的任务消失了。因为我们现在的数据库是空的，我们需要插入一些任务。 从服务端数据库控制台插入任务我们称集合中的每一项为文档。使用服务端数据库控制台插入一些文档到我们的集合中。在一个新的terminal中进入你的app项目目录，并键入： 1meteor mongo 这会在你app的本地开发数据库中打开一个控制台。键入下面的代码： 1db.tasks.insert(&#123; text: &quot;Hello world!&quot;, createdAt: new Date() &#125;); 在浏览器中，你可以立刻看到用户界面更新并展示了这个新的任务。可以看到，我们不需要编写任何代码将服务端数据库连接到前端——一切都是自动的。 用同样的方法从数据库控制台添加一些不同的任务吧。在下一章节，我们将了解怎样在app用户界面增加一些功能，比如不使用数据库控制台去增加任务。 4.使用表单添加任务在这一章节，我们将增加一个表单字段，给用户在列表中添加任务。 首先，让我们增加一个表单域到App组件中： 123456789101112131415//imports/ui/App.jsx&lt;div className="container"&gt; &lt;header&gt; &lt;h1&gt;Todo List&lt;/h1&gt; &lt;form className="new-task" onSubmit=&#123;this.handleSubmit.bind(this)&#125; &gt; &lt;input type="text" ref="textInput" placeholder="Type to add new tasks" /&gt; &lt;/form&gt; &lt;/header&gt; &lt;ul&gt; 提示：JSX中添加注释的方法：{/* … */} 你可以看到form元素有一个onSubmit属性，它映射到组件的handleSubmit方法。在React中，你可以这样监听浏览器事件，就像表单上的submit事件。input元素有一个ref属性，它能让我们稍后轻松的访问到这个元素。 让我们添加handleSubmit放到到App组件里： 1234567891011121314151617181920212223242526//imports/ui/App.jsximport React, &#123; Component, PropTypes &#125; from 'react';import ReactDOM from 'react-dom';import &#123; createContainer &#125; from 'meteor/react-meteor-data';import &#123; Tasks &#125; from '../api/tasks.js';//...省略一些代码...class App extends Component &#123; handleSubmit(event) &#123; event.preventDefault(); // 通过React的ref拿到文本字段 const text = ReactDOM.findDOMNode(this.refs.textInput).value.trim(); Tasks.insert(&#123; text, createdAt: new Date(), // 当前时间 &#125;); // 清空表单 ReactDOM.findDOMNode(this.refs.textInput).value = ''; &#125; //...省略一些代码...&#125; 现在你的App有一个新的表单字段了。只需要在输入框输入文本，并按下回车键，就可以添加任务了。如果你打开一个新的浏览器窗口并再打开这个app，你会发现列表会自动自动在所有客户端同步。 在React中监听事件就如你看到的，你可以通过参考组件上切确的方法来管理DOM事件。在事件管理器内部，你可以通过使用React.findDOMNode去拿到带有ref属性的元素。查看更多React支持的事件类型，以及事件系统如何运行的，请参考React文档。 插入集合在事件管理器内部，我们通过调用Tasks.insert添加了一个任务到tasks集合，因为我们不用为集合定义一个模式，所以可以添加任何属性到任务对象，比如创建时间。 客户端可以添加任何数据到数据库，这样并不安全，但目前来说一切都没问题。在第10章节，我们将学习怎样安全并有限制的将数据插入到数据库中。 储存我们的任务目前，我们最新的任务在列表的最底下。这对任务列表来说不是很好，我们希望看到最新的任务在最前面。 我们可以通过使用createdAt字段自动排序来解决此问题。只需在包裹App组件的数据容器内的find方法调用时添加一个排序选项： 123456//imports/ui/App.jsxexport default createContainer(() =&gt; &#123; return &#123; tasks: Tasks.find(&#123;&#125;, &#123; sort: &#123; createdAt: -1 &#125; &#125;).fetch(), &#125;;&#125;, App); 回到浏览器，并确认是否如期运行：任何新添加的任务都会出现在列表的最顶端，而不是底部。 在下一章节，我们会增加一些十分重要的待办事项列表特性：检查任务和删除任务。 5.检查任务和删除任务到目前为止，我们还仅仅只能插入文档。现在，我们将学习怎么去更新和删除它们。 让我们添加两个新元素到我们的组件，一个复选框和一个删除按钮，以及它们对应的时间管理器： 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component, PropTypes &#125; from 'react';import &#123; Tasks &#125; from '../api/tasks.js';// Task组件 - 代表一个单独的代办事项export default class Task extends Component &#123; toggleChecked() &#123; // 设置checked属性和当前值相反 Tasks.update(this.props.task._id, &#123; $set: &#123; checked: !this.props.task.checked &#125;, &#125;); &#125; deleteThisTask() &#123; Tasks.remove(this.props.task._id); &#125; render() &#123; //当修改checked后，给tasks一个不同的className // 以便我们更好的在CSS中修改样式 const taskClassName = this.props.task.checked ? 'checked' : ''; return ( &lt;li className=&#123;taskClassName&#125;&gt; &lt;button className="delete" onClick=&#123;this.deleteThisTask.bind(this)&#125;&gt; &amp;times; &lt;/button&gt; &lt;input type="checkbox" readOnly checked=&#123;this.props.task.checked&#125; onClick=&#123;this.toggleChecked.bind(this)&#125; /&gt; &lt;span className="text"&gt;&#123;this.props.task.text&#125;&lt;/span&gt; &lt;/li&gt; ); &#125;&#125; 更新在上面代码中，我们调用Tasks.update去检查一个任务。 集合上的更新功能需要两个参数。第一个参数是标识集合子集的选择器，第二个是一个update参数，用来指定要对匹配对象做什么。 在这个例子中，选择器就是相对应的任务的_id，update参数用$set去切换checked字段，这将代表任务是否已经完成。 删除上面代码使用Tasks.remove去删除任务。remove函数只需要一个参数，一个选择器，用于确定要在集合中删除的项目。 6.在Android或iOS上运行app 目前，Meteor并不支持在Windows上进行移动端打包。如果你是Windows用户，请忽略这一章节。 目前为止，我们构建了我们的app，并在浏览器上对它进行测试，但是Meteor是为了跨平台而设计的——只需要几句命令，就可以把你的待办事项列表网站构建成Android或iOS应用。 Meteor可以轻松的设置所有构建app所需的工具，但是下载所有程序可能需要一段时间——Android大约300M，iOS要安装Xcode大约2GB，如果你不希望下载这些工具，你可以调到下一个章节。 在iOS模拟器上运行如果你有Mac，你可以运行在iOS模拟器上运行app。 进入到app目录并键入： 1meteor install-sdk ios 它会安装你构建iOS app所要用到的所有所有配置。当上面安装完成，键入： 12meteor add-platform iosmeteor run ios 你会看到iOS模拟器弹出，并且你的app在里面运行。 在Android模拟器上运行在terminal中进入你的app目录并键入： 1meteor install-sdk android 它会安装你构建Android app所要用到的所有所有配置。当上面安装完成，键入： 1meteor add-platform android 同意协议条款，键入： 1meteor run android 在一些初始化后，我们将看到一个Android模拟器弹出，你的app在原生生Android容器里运行。 模拟器运行可能会有一些慢，所以如果你想看到应用真实的情况，还得到真实设备上使用。 在Android设备上运行首先，完成上述的所有Android设置步骤。然后，确定你的设备有USB调试模式而且手机插进了电脑的USB插口。此外，你必须在真机运行前关闭安卓模拟器。 接下来，键入以下命令： 1meteor run android-device 你的app将会构建并安装到你的设备上。 在iPhone或iPad上运行（只限Mac：要有苹果开发者账号）如果你有苹果开发者账号，你也可以在iOS设备上运行你的app。键入以下命令： 1meteor run ios-device 这将会为你的iOS app项目打开Xcode。你可以使用Xcode让app运行在任何Xcode支持的设备或模拟器上。 现在我们看到了在移动端运行我们的app多么容易，让我们给app再添加一些特性。 7.在组件状态中存储临时的用户界面数据在这一章节，我们将在app中添加客户端数据过滤功能，以便用户选择只查看未完成的任务。我们将学习怎样使用React的component state去存储只在客户端用到的临时数据。 首先，我们需要增加一个复选框到App组件： 123456789101112131415//imports/ui/App.jsx&lt;header&gt; &lt;h1&gt;Todo List&lt;/h1&gt;//新添加内容 &lt;label className="hide-completed"&gt; &lt;input type="checkbox" readOnly checked=&#123;this.state.hideCompleted&#125; onClick=&#123;this.toggleHideCompleted.bind(this)&#125; /&gt; Hide Completed Tasks &lt;/label&gt;//新添加内容 你可以看到它从this.state.hideCompleted读取数据。React有一个特殊的字段叫state，你可以把组件数据存储和封装在里面。我们需要在组件的构造器中初始化this.state.hideCompleted的值： 12345678910111213//imports/ui/App.jsxclass App extends Component &#123; //新添加的内容 constructor(props) &#123; super(props); this.state = &#123; hideCompleted: false, &#125;; &#125; //新添加的内容&#125; 我们可以事件管理器中调用this.setState去更新this.state，这将异步更新state属性，并重新渲染组件： 123456789101112//imports/ui/App.jsx ReactDOM.findDOMNode(this.refs.textInput).value = ''; &#125; //新添加的内容 toggleHideCompleted() &#123; this.setState(&#123; hideCompleted: !this.state.hideCompleted, &#125;); &#125;//新添加的内容&#125; 当this.state.hideCompleted为true时，我们需要更新renderTasks方法去过滤已经完成的任务： 1234567891011//imports/ui/App.jsxrenderTasks() &#123; let filteredTasks = this.props.tasks; if (this.state.hideCompleted) &#123; filteredTasks = filteredTasks.filter(task =&gt; !task.checked); &#125; return filteredTasks.map((task) =&gt; ( &lt;Task key=&#123;task._id&#125; task=&#123;task&#125; /&gt; ));&#125; 如果你现在选择复选框，任务列表不会再展现已经完成的任务了。 新的特性：显示未完成任务的数目现在我们要写一个查询条件，用来过滤掉已经完成的任务。我们也可以用相同的查询来显示已完成的任务总数。为此，我们需要在我们的数据容器中拿到一个计数，并在render方法中添加一行代码。因为我们已经有客户端集合中的数据，增加这个额外的计数不需要向服务端发起任何请求。 12345678910//imports/ui/App.jsxexport default createContainer(() =&gt; &#123; return &#123; tasks: Tasks.find(&#123;&#125;, &#123; sort: &#123; createdAt: -1 &#125; &#125;).fetch(), //新添加的的内容 incompleteCount: Tasks.find(&#123; checked: &#123; $ne: true &#125; &#125;).count(), //新添加的的内容 &#125;;&#125;, App); 12345678910111213141516171819//imports/ui/App.jsxreturn ( &lt;div className="container"&gt; &lt;header&gt; //新添加的的内容 &lt;h1&gt;Todo List (&#123;this.props.incompleteCount&#125;)&lt;/h1&gt; //新添加的的内容 &lt;label className="hide-completed"&gt; &lt;input//...省略一些代码...App.propTypes = &#123; tasks: PropTypes.array.isRequired, //新添加的的内容 incompleteCount: PropTypes.number.isRequired, //新添加的的内容&#125;;) 8.添加账户Meteor自带一个账户系统和用户登录接口，让你在短短几分钟就能添加多用户功能到你的app内。 目前，Meteor使用Blaze UI组件作为它的默认UI引擎。在未来，也可能会有专为React定制的组件。 开启账户系统和UI，我们需要增加相对应的包。在你的app目录，运行以下命令： 1meteor add accounts-ui accounts-password 在React中写Blaze组件要通过accounts-ui包使用Blaze UI，我们需要把它包裹在React组件中。这样让我们在新文件中创建了一个叫AccountsUIWrapper的新组件： 12345678910111213141516171819202122//imports/ui/AccountsUIWrapper.jsximport React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';import &#123; Template &#125; from 'meteor/templating';import &#123; Blaze &#125; from 'meteor/blaze';export default class AccountsUIWrapper extends Component &#123; componentDidMount() &#123; //使用Meteor Blaze渲染登录按钮 this.view = Blaze.render(Template.loginButtons, ReactDOM.findDOMNode(this.refs.container)); &#125; componentWillUnmount() &#123; //清除Blaze视图 Blaze.remove(this.view); &#125; render() &#123; //只渲染一个占位符容器即可 return &lt;span ref="container" /&gt;; &#125;&#125; 在App中定义刚刚创建的组件： 123456789101112131415161718//imports/ui/App.jsximport &#123; Tasks &#125; from '../api/tasks.js';import Task from './Task.jsx';//...新添加的代码...import AccountsUIWrapper from './AccountsUIWrapper.jsx';//...新添加的代码...class App extends Component &#123;//...省略一些代码... Hide Completed Tasks &lt;/label&gt; //...新添加的代码... &lt;AccountsUIWrapper /&gt; //...新添加的代码...&#125; 接下来，增加下列代码去配置accounts UI，用username去替换email address: 1234567//imports/startup/accounts-config.jsimport &#123; Accounts &#125; from 'meteor/accounts-base';Accounts.ui.config(&#123; passwordSignupFields: 'USERNAME_ONLY',&#125;); 同时我们需要在客户端入口导入这个配置文件： 123456789//client/main.jsximport &#123; Meteor &#125; from 'meteor/meteor';import &#123; render &#125; from 'react-dom';//...新添加的代码...import '../imports/startup/accounts-config.js';//...新添加的代码...import App from '../imports/ui/App.jsx'; 添加用户相关功能 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
        <tag>Full-Stack</tag>
        <tag>Meteor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You Don't Need jQuery - Query Selector]]></title>
    <url>%2F2017%2F04%2F01%2F2017-04-01-you-dont-need-jq-query-selector%2F</url>
    <content type="text"><![CDATA[GitHub地址：https://github.com/oneuijs/You-Dont-Need-jQuery 常用的 class、id、属性 选择器都可以使用 document.querySelector 或 document.querySelectorAll 替代。区别是 document.querySelector 返回第一个匹配的 Element document.querySelectorAll 返回所有匹配的 Element 组成的 NodeList。它可以通过 [].slice.call() 把它转成 Array 如果匹配不到任何 Element，jQuery 返回空数组 []，但 document.querySelector 返回 null，注意空指针异常。当找不到时，也可以使用 || 设置默认的值，如 document.querySelectorAll(selector) || [] 注意：document.querySelector 和 document.querySelectorAll 性能很差。如果想提高性能，尽量使用 document.getElementById、document.getElementsByClassName 或 document.getElementsByTagName。 1.0 Query by selector 12345// jQuery$('selector');// Nativedocument.querySelectorAll('selector'); 1.1 Query by class 12345678// jQuery$('.css');// Nativedocument.querySelectorAll('.css');// ordocument.getElementsByClassName('css'); 1.2 Query by id 12345678// jQuery$('#id');// Nativedocument.querySelector('#id');// ordocument.getElementById('id'); 1.3 Query by attribute 12345// jQuery$('a[target=_blank]');// Nativedocument.querySelectorAll('a[target=_blank]'); 1.4 Find sth. Find nodes 12345// jQuery$el.find('li');// Nativeel.querySelectorAll('li'); Find body 12345// jQuery$('body');// Nativedocument.body; Find Attribute 12345// jQuery$el.attr('foo');// Nativee.getAttribute('foo'); Find data attribute 12345678// jQuery$el.data('foo');// Native// using getAttributeel.getAttribute('data-foo');// you can also use `dataset` if only need to support IE 11+el.dataset['foo']; 1.5 Sibling/Previous/Next Elements Sibling elements 1234567// jQuery$el.siblings();// Native[].filter.call(el.parentNode.children, function(child) &#123; return child !== el;&#125;); Previous elements 12345// jQuery$el.prev();// Nativeel.previousElementSibling; Next elements 123// next$el.next();el.nextElementSibling; 1.6 Closest Closest 获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。 12345678910111213141516// jQuery$el.closest(queryString);// Nativefunction closest(el, selector) &#123; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; while (el) &#123; if (matchesSelector.call(el, selector)) &#123; return el; &#125; else &#123; el = el.parentElement; &#125; &#125; return null;&#125; 1.7 Parents Until 获取当前每一个匹配元素集的祖先，不包括匹配元素的本身。 12345678910111213141516171819202122// jQuery$el.parentsUntil(selector, filter);// Nativefunction parentsUntil(el, selector, filter) &#123; const result = []; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; // match start from parent el = el.parentElement; while (el &amp;&amp; !matchesSelector.call(el, selector)) &#123; if (!filter) &#123; result.push(el); &#125; else &#123; if (matchesSelector.call(el, filter)) &#123; result.push(el); &#125; &#125; el = el.parentElement; &#125; return result;&#125; 1.8 Form Input/Textarea 12345// jQuery$('#my-input').val();// Nativedocument.querySelector('#my-input').value; Get index of e.currentTarget between .radio 12345// jQuery$(e.currentTarget).index('.radio');// Native[].indexOf.call(document.querySelectorAll('.radio'), e.currentTarget); 1.9 Iframe Contents jQuery 对象的 iframe contents() 返回的是 iframe 内的 document Iframe contents 12345// jQuery$iframe.contents();// Nativeiframe.contentDocument; Iframe Query 12345// jQuery$iframe.contents().find('.css');// Nativeiframe.contentDocument.querySelectorAll('.css'); 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 文档操作]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-mongodb-document-query%2F</url>
    <content type="text"><![CDATA[插入文档insert()语法格式 insert() 方法的基本格式为:&gt;db.COLLECTION_NAME.insert(document) 范例1 1234567891011&gt;db.mycol.insert( &#123; &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;Shock&quot;, &quot;url&quot;: &quot;https://rockjins.js.org&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot; &#125;) mycol 是上一节所创建的集合的名称。如果数据库中不存在该集合，那么MongoDB会创建该集合，并向其中插入文档。 在插入的文档中，如果我们没有指定_id参数，那么MongoDB会自动为文档指定一个唯一的 ID。_id是一个 12 字节长的 16 进制数，这 12 个字节的分配如下: _id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer) 你还可以将用 insert() 方法传入一个文档数组，范例如下: 范例2 1234567891011121314151617181920212223242526&gt;db.post.insert([ &#123; title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by: &apos;tutorials point&apos;, url: &apos;http://www.tutorialspoint.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100 &#125;, &#123; title: &apos;NoSQL Database&apos;, description: &apos;NoSQL database doesn&apos;t have tables&apos;, by: &apos;tutorials point&apos;, url: &apos;http://www.tutorialspoint.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 20, comments: [ &#123; user:&apos;user1&apos;, message: &apos;My first comment&apos;, dateCreated: new Date(2013,11,10,2,35), like: 0 &#125; ] &#125;]) save()如果没有指定文档的_id，那么save()和insert()完全一样。 如果指定了_id，那么它就会覆盖掉save()方法中指定_id的文档的全部数据。 查询文档find()查询 MongoDB 集合中的数据，使用 find() 方法。 语法格式 find() 方法基本格式为： &gt;db.COLLECTION_NAME.find() find() 会以非结构化的方式来显示所有文档 pretty()以结构化方式显示结果，使用 pretty()方法。 语法格式 &gt;db.COLLECTION_NAME.find().pretty() 范例 1234567891011&gt;db.mycol.find().pretty()&#123; &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;Shock&quot;, &quot;url&quot;: &quot;https://rockjins.js.org&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;&#125;&gt; find()还有一个扩展方法findOne()，只返回一个文档。 MongoDB 中类似WHERE子句的语句 操作 格式 范例 RDBMS中的类似语句 等于 {&lt;key&gt;:&lt;value&gt;} db.mycol.find({&quot;by&quot;:&quot;Shock&quot;}).pretty() where by = &#39;Shock&#39; 小于 {&lt;key&gt;:{$lt:&lt;value&gt;}} db.mycol.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50 小于或等于 {&lt;key&gt;:{$lte:&lt;value&gt;}} db.mycol.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50 大于 {&lt;key&gt;:{$gt:&lt;value&gt;}} db.mycol.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50 大于或等于 {&lt;key&gt;:{$gte:&lt;value&gt;}} db.mycol.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {&lt;key&gt;:{$ne:&lt;value&gt;}} db.mycol.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 MongoDB中的AND条件语法格式 在 find() 方法中，如果传入多个键，并用逗号( , )分隔它们，那么 MongoDB 会把它看成是 AND 条件。AND 条件的基本语法格式为: &gt;db.mycol.find({key1:value1, key2:value2}).pretty() 范例 下例将展示所有由 “Shock” 发表的标题为 “MongoDB Overview” 的教程。 1234567891011&gt;db.mycol.find(&#123;&quot;by&quot;:&quot;tutorials point&quot;,&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;).pretty()&#123; &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;Shock&quot;, &quot;url&quot;: &quot;https://rockjins.js.org&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;&#125;&gt; 对于上例这种情况，RDBMS 采用的 WHERE 子句将会是: where by=&#39;tutorials point&#39; AND title=&#39;MongoDB Overview&#39; 你可以在 find 子句中传入任意的键值对。 MongoDB中的OR条件语法格式 若基于OR条件来查询文档，可以使用关键字 $or。OR条件的基本语法格式为: 1234567&gt;db.mycol.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 范例 下例将展示所有由 “Shock” 发表的或标题为 “MongoDB Overview” 的教程。 1234567891011&gt;db.mycol.find(&#123;$or:[&#123;&quot;by&quot;:&quot;tutorials point&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;]&#125;).pretty()&#123; &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;Shock&quot;, &quot;url&quot;: &quot;https://rockjins.js.org&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;&#125;&gt; 结合使用AND与OR条件范例 下例所展示文档的条件为:喜欢数大于100，标题是“MongoDB Overview”，或者是由“Shock” 所发表的。相应的SQL WHERE子句为:where likes&gt;10 AND (by = &#39;tutorials point&#39; OR title = &#39;MongoDB Overview&#39;)。 1234567891011&gt;db.mycol.find(&#123;&quot;likes&quot;: &#123;$gt:10&#125;, $or: [&#123;&quot;by&quot;: &quot;Shock&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;]&#125;).pretty()&#123; &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;Shock&quot;, &quot;url&quot;: &quot;https://rockjins.js.org&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;&#125;&gt; 更新文档MongoDB 中的 update() 与 save() 方法都能用于更新集合中的文档。 update() 方法更新已有文档中的值，而 save() 方法则是用传入该方法的文档来替换已有文档。 update()方法update()方法更新已有文档中的值。 语法格式 update() 方法基本格式如下: &gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA) 范例 假如mycol集合中有下列数据: 123&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point Overview&quot;&#125; 下面的例子将把文档原标题 ‘MongoDB Overview’ 替换为新的标题 ‘New MongoDB Tutorial’。 123456&gt;db.mycol.update(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;New MongoDB Tutorial&apos;&#125;&#125;)&gt;db.mycol.find()&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;New MongoDB Tutorial&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point Overview&quot;&#125;&gt; MongoDB默认只更新单个文档，要想更新多个文档，需要把参数multi设为true。 &gt;db.mycol.update({&#39;title&#39;:&#39;MongoDB Overview&#39;},{$set:{&#39;title&#39;:&#39;New MongoDB Tutorial&#39;}},{multi:true}) save()方法save() 方法利用传入该方法的文档来替换已有文档。 语法格式 save() 方法基本语法格式如下: &gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA}) 范例 下例用_id为’5983548781331adf45ec5’的文档代替原有文档。 12345678910&gt;db.mycol.save( &#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;Tutorials Point New Topic&quot;, &quot;by&quot;:&quot;Tutorials Point&quot; &#125;)&gt;db.mycol.find()&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;Tutorials Point New Topic&quot;, &quot;by&quot;:&quot;Tutorials Point&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point Overview&quot;&#125;&gt; 删除文档remove()方法MongoDB利用 remove() 方法 清除集合中的文档。它有2个可选参数: deletion criteria:(可选)删除文档的标准。 justOne:(可选)如果设为true或1，则只删除一个文档。 语法格式 remove() 方法的基本语法格式如下所示:&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA) 范例 假如 mycol 集合中包含下列数据: 123&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point Overview&quot;&#125; 下面我们将删除其中所有标题为 ‘MongoDB Overview’ 的文档。 12345&gt;db.mycol.remove(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;)&gt;db.mycol.find()&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point Overview&quot;&#125;&gt; 只删除一个文档如果有多个记录，而你只想删除第一条记录，那么就设置remove()方法中的justOne参数： &gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1) 删除所有文档如果没有指定删除标准，则 MongoDB 会将集合中所有文档都予以删除。这等同于 SQL 中的 truncate 命令。 123&gt;db.mycol.remove()&gt;db.mycol.find()&gt; 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速将Promise运用在开发中]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-promise-dev%2F</url>
    <content type="text"><![CDATA[这篇文章面向对Promise不甚了解的朋友，我将告诉你如何把它快速运用在开发中。 什么是Promise？简单几句介绍一下。Promise是抽象异步处理对象以及对其进行各种操作的组件。你可以理解为：它的出现，是为了让我们更方便的进行异步处理。 在Promise出现之前，说到JavaScript的异步处理，我们都会想到回调函数,like this: 12345getAsync("fileA.txt", function(error, result)&#123; if(error)&#123;// 取得失败时的处理 throw error; throw error; &#125;&#125;); 上面遵循Node.js的规定，回调的第一个参数是error。如果所有的回调函数都像Node.js一样，统一参数使用规则的话，那写法会很明了，但也仅仅是编码规范而已，使用不同的写法也不会出错。 而Promise则是把异步处理对象和处理规则进行规范化，并采用统一的接口来编写，使用规定方法之外的写法都会出错。 我们可以先看一个简单的使用Promise进行异步处理的例子: 1234567var promise = getAsyncPromise("fileA.txt");promise.then(function(result)&#123; // 获取文件内容成功时的处理&#125;).catch(function(error)&#123; // 获取文件内容失败时的处理&#125;); 看上去和回调函数有些不一样，在使用Promise进行异步处理的时候，我们必须按照接口规定的方法编写处理代码。 也即是说，除了使用Promise规定的方法(上面的then和catch),其他的方法都是不能使用的，而回调函数可以自定义回调的参数。 所以，Promise可以将复杂的异步处理轻松的进行模式化，没有理由让你不使用它。 接下来，我们看看怎么把Promise运用到开发中，这个才是大家想了解的。 学习Promise在运用到开发之前，我们有必要先学习一些Promise的基本API(暂时看的有点糊涂没关系，等会的例子实践会和大家讲清楚的)。 目前大致有下面三种类型: 1.Constructor(构造器)我们从构造函数Promise来创建一个新promise对象作为接口。 要创建一个promise对象，可以使用new来调用Promise构造器来进行实例化。 123var promise = new Promise(function(resolve, reject) &#123; // 异步处理 // 处理结束后、调用resolve 或 reject&#125;); 2.Instance Method(实例方法)在通过new生成的promise对象时，我们设置了在resolve(成功)和reject(失败)时调用的回调函数，我们可以使用promise.then()实例方法。 1promise.then(onFulfilled,onReject); resolve(成功)时：onFulfilled会被调用 reject(失败)时：onReject会被调用 onFulfilled和onReject都为可选参数 promise.then成功和失败时都可以使用，另外在异常处理时，可以使用promise.then(undefined, onReject)这种方式，只指定reject时的回调函数即可。不过这种情况下，使用promise.catch()是个明智之选。 1promise.catch(onReject); 3.Static Method(静态方法)像promise.all()和Promise.resolve()等在内，主要都是一些辅助方法(可以理解为一些语法糖)，这里不作深入探讨。 运用在开发中我们先来看一段Promise使用流程代码： 12345678910111213function asyncFunction() &#123; //(1) return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve('Async Hello World'); &#125;, 300); &#125;);&#125;asyncFunction().then(function(value) &#123; //(2) console.log(value); //300ms后打印 "Async Hello World"&#125;).catch(function(error) &#123; //(3) console.log(error);&#125;) 分析一下上面代码。 执行(1)处函数，会返回一个Promise对象，Promise对象内部在300ms后执行resolve()方法，这个方法调用(2)处的then()方法，并传入参数，如果Promise对象内部出现任何错误(比如平台不支持setTimeout方法)，就会执行(3)处的catch()发放，并把错误作为参数传入。 这里提一下，我看到很多朋友把Promise理解为Ajax的一种扩展，其实并不是这样的，Ajax只是一种请求数据的方式，因为Ajax是异步的，所以我们可以用Promise去管理Ajax请求，但这并不意味这Promise只服务于Ajax，只要是异步处理，我们都可以使用Promise去处理，就比如上面的setTimeout。 看到这里大家对Promise应该有一个大概的认识了，实际开发中Promise大部分时间还是搭配Ajax使用，我们来看看应该怎么做，下面用原生的方式请求Ajax，大家也温习一下： 1234567891011121314151617181920212223242526272829function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125;else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject.(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;// 运行示例var URL = "https://rockjins.js.org";getURL(URL).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;); getURL只有在XHR取得状态为200时才会调用resolve，也就是数据取得成功时，而其他情况(数据取得失败)则会调用reject。 当调用resolve(req.responseText)时，then方法也会被调用，并接收到req.responseText参数。 熟悉Node.js的朋友在写回调时会会将callback(error,response)的第一个参数设为error对象，在Promise中，resolve(成功)/reject(失败)担当了这个职责。 XHR中onerror触发时，就是发生错误时，理所当然要调用reject，我们重点来看下传给reject的值。 发生错误时要像这样reject(new Error(req.statusText))，创建一个Error对象再讲具体的值传入进去。传给reject的值也没有什么特殊限制，一般只要是Error对象(或继承自Error对象)即可。 小结其实你理解了Promise的运作流程，使用它十分方便和简单，它就是一个异步管理器，帮助我们更好地去进行异步处理。 试想，如果Promise真的很复杂，那它出现的意义是什么？本末倒置了，哈哈。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』你也许并不需要构建工具]]></title>
    <url>%2F2017%2F03%2F08%2F2017-03-08-you-might-not-need-a-build-tool%2F</url>
    <content type="text"><![CDATA[Read the original 我们最好了解”原生”的构建方式 译者注：这篇文章旨在告诉大家，构建的过程是怎样的。因为现在太多的脚手架工具了，大家确实很方便就搭建了环境，但内部的过程却让人迷糊。 前言构建工具变得越来越丰富多彩了，但是你真的需要它们吗？有没有更简单的方式去搭建Rollup、Stylus或者其它的环境，而不用花上一整天时间。 现在我要向你展示用“原生”的方式构建项目，使用NPM scripts和监听器(chokidar)。 初始化node.js项目我们先创建一个node.js项目。打开你的命令行输入以下命令： 123$ mkdir example$ cd example$ npm init -y 然后创建一些文件夹并安装express： 12$ mkdir -p css js public/js public/css$ npm i express --save 然后，我们需要一个简单的web服务器(译者注：因为我使用的atom编辑器，所以使用atom命令可以直接创建server.js并打开它)： 12$ touch server.js$ atom server.js 接下来要把public文件夹对外开发，在server.js中写入如下代码： 123456const path = require(&apos;path&apos;);const express = require(&apos;express&apos;);const app = express();const PUBLIC = path.join(__dirname, &apos;public&apos;);app.use(express.static(PUBLIC));app.listen(8080); 创建一些NPM scripts接下来我们要安装JS和CSS工具。如果你喜欢的话，可以选择你中意的工具。 1$ npm i stylus nib rollup rollup-plugin-buble uglify-js --save-dev 接下来可以增加一些npm scripts，先打开package.json： 12$touch package.json$atom package.json npm scripts的美妙之处就在于，你所有的依赖关系都可以安装在本地，并按照官方文档去执行命令，在package.json中写入如下代码： 123456789101112131415&#123; "name": "example", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "dev": "node watch", "build-css": "stylus -u nib css/index.styl -o public/css/main.css", "build-js": "rollup -c -f iife js/index.js -o public/js/main.js", "uglify-js": "uglifyjs public/js/index.js -cmo public/js/main.min.js" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 让我们开始编辑详情： 1stylus -u nib css/index.styl -o public/css/main.css 上面这句命令执行顺序： 运行stylus 加载nib插件 打开css/index.styl 编辑public/css/main.css 1rollup -c -f iife js/index.js -o public/js/main.js 上面这句命令执行顺序： 运行rollup 使用配置文件（我们将在接下来创建它） 格式化IIFE 打开js/index.js 编辑public/js/main.js 1uglifyjs public/js/main.js -cmo public/js/main.min.js 上面这句命令的执行顺序： 运行uglify-js 打开public/js/main.js 压缩&amp;最小化 编辑public/js/main.min.js 配置Rollup接下来我们要创建rollup的配置文件： 12$ touch rollup.config.js$ atom rollup.config.js 没有多少要配置的： 123456import buble from 'rollup-plugin-buble';export default &#123; plugins: [ buble() ]&#125;; 这样就够了. 创建一个文件监听器还有一件事。我们需要一个文件监听器，让我们来安装chokidar： 1$ npm i chokidar --save-dev 然后创建一个watch.js： 12$ touch watch.js$ atom watch.js 这里是它的内容： 12345678910111213141516require('./server'); // run the serverconst cp = require('child_process');const chokidar = require('chokidar');run('build-css');run('build-js');chokidar.watch('css/**/*.styl') .on('change', path =&gt; run('build-css'));chokidar.watch('js/**/*.js') .on('change', path =&gt; run('build-js'));chokidar.watch('public/js/main.js') .on('change', path =&gt; run('uglify-js'));function run (scriptName) &#123; const child = cp.spawn('npm', ['run', scriptName]); child.stdout.pipe(process.stdout); child.stderr.pipe(process.stderr);&#125; 好了！这是上面这段代码运行的过程： 运行服务 加载node.js自带的child_process包 运行npm run build-css命令 运行npm run build-js命令 开始监听css/**/*.styl和npm run build-css的任何变化 开始监听js/**/*.js和npm run build-js的任何变化 开始监听public/js/main.js和npm run uglify-js的任何变化 定义一个简单的脚本运行错误处理机制 我们需要一些内容我们需要添加一些CSS： 12$ touch css/index.styl$ atom css/index.styl 这是一个很简单的”bootstrap”： 1234@import &apos;nib&apos;;body &#123; font-family: sans-serif;&#125; …还有JS： 12$ touch js/index.js$ atom js/index.js 这里同样也没有太多事情发生： 123const hello = document.createElement('h1');hello.textContent = 'Hello world!';document.body.appendChild(hello); 还需要一些HTML： 12$ touch public/index.html$ atom public/index.html 也是最基本的… 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/main.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 完成!让我们试试看： 1$ npm run dev 在浏览器地址栏输入http://localhost:8080 搞定，没问题！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[举个小栗子来聊下性能优化]]></title>
    <url>%2F2017%2F03%2F06%2F2017-03-06-performance-optimum%2F</url>
    <content type="text"><![CDATA[我向来是先实现功能再考虑优化，不然就本末倒置了。 网上有很多关于前端优化的帖子，最出名的应该是雅虎前端优化35条军规了，但其实很多朋友看完就忘了，确实要记住这么多条优化建议有困难。但你吸收这些优化建议后，你的潜意识就会慢慢养成优化的习惯，看到不完美的代码你就会不自觉的想到怎样去优化它们。 今天就举一个小栗子,我们来聊聊怎样做前端优化。 产品经理进门：“小周，这次的项目要兼容到IE8。” 我：“好的，没问题…”(除了这个我还能说什么？) 好了，假设不能使用第三方库，我们要用原生JS实现DOM元素事件绑定，我们就要考虑到兼容性问题(这时候脑子里面不用想优化的问题，先想想怎么实现功能吧)。 我最初可能会这么写: 12345678var addEvent = function(elem, type, handler) &#123; if(window.addEventListener) &#123; return elem.addEventListener(type, handler, false); &#125; if(window.attachEvent) &#123; return elem.attachEvent('on' + type, handler); &#125;&#125;; 上面的代码没有问题，完美兼容到了IE8，功能算是实现了，这时候我们就要开始考虑性能优化的问题了。 先来看看这个函数有什么缺点，每次执行函数时都会进入if条件分支，虽然对于现代浏览器来说，执行这些分支开销很小，但就是这些细节，区分了优秀与平庸。 我们可以再想一个方案来让这个功能实现的更完美，我们把嗅探浏览器的操作提前到代码加载时执行，在代码加载时就进行判断，让addEvent返回一个包裹了一个正确逻辑的函数，这里可以用自执行函数来做。 123456789101112var addEvent = (function() &#123; if(window.addEventListener) &#123; return function(elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; if (window.attachEvent) &#123; return function(elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125;&#125;)(); 这样写仍然有个缺点，或许从头到尾我们都没有用过addEvent函数，那自执行函数中的浏览器嗅探完全是多余的，而且会延长页面ready的时间。 想想看还有什么方法可以优化首屏加载。 我们仍然把addEvent声明为一个普通函数，在函数中仍然有判断分支。但在第一次进入分支后，函数内部重写addEvent函数，从而得到我们所期望的addEvent函数，下次调用addEvent函数时，内部将不再进行分支判断: 123456789101112var addEvent = function(elem, type, handler) &#123; if(window.addEventListener) &#123; addEvent = function(elem, type, handler) &#123; //重写addEvent函数 elem.addEventListener(type, handler, false); &#125; &#125;else if(window.attachEvent) &#123; addEvent = function(elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125; addEvent(elem, type, handler);&#125; 回过头再对比最初的函数，发现其实优化也不是那么困难，最重要的时我们要养成优化代码的习惯，看到一段代码，就要开始思考有哪些可以改进的地方，如果你想要成为一名优秀的程序员，这一点是必不可少的，量变引发质变这个道理大家都懂。 如果你还没有养成这种习惯，那试着带着这种思维习惯去review自己的代码，你会发现，呵呵… 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』"typeof null是什么?"以及其它让我们感到困惑的JavaScript类型]]></title>
    <url>%2F2017%2F02%2F22%2F2017-02-22-javascript-types%2F</url>
    <content type="text"><![CDATA[Read the original 前言typeof运算符在JavaScript中用来判断一个数据的类型，它返回一个字符串。比如，我们想知道123的数据类型，我们可能这样写： 1typeof 123 它会返回123的数据类型，那么应该是”number”。除了”number”，typeof运算符还会返回其他6种结果： 12345678910111213typeof 123 // "number"typeof "abc" // "string" typeof true // "boolean" typeof &#123;a: 1&#125; // "object" typeof function foo() &#123;&#125; // "function" typeof undefined // "undefined" typeof Symbol('foo') // "symbol" 从上面的例子中可以看出，typeof运算符使用十分简单。但是，这只是很少的一部分案例，它们很容易让人误解和混淆typeof运算符究竟是怎样运作的。 typeof typeof 123是什么类型？1typeof typeof 123 //"string" typeof运算符返回的值是什么类型？好的，typeof操作符总是以字符串的形式返回传递给它的值的数据类型。如果去获取typeof计算后返回的值，比如一个数字，它将会是&quot;number&quot;。这意味着，无论结果是什么类型，我们去判断一个typeof [any operand]，永远都是返回字符串。 typeof NaN是什么类型？1typeof NaN //"number" NaN代表某个值不是一个数字，但出乎意料的是，它是”number”类型。原因是这样的，在计算机内部，NaN是以数字类型储存的。然而，它是一个不能用实际数字来表示的数值类型的值。所以它叫“Not a Number”，这并不意味着它不是数值类型。相反，它意味着这个值不能用数值表示。 这也解释了为什么NaN的值都不相等。比如： 1234const NaN1 = 2 * "abc"; const NaN2 = 2 * "abc";NaN1 === NaN2 // false 上面两个NaN的值不相等，因为它们不能用两个相同的数字来表示。 typeof [1, 2, 3]是什么类型？1typeof [1,2,3] // "object" 对数组使用typeof会得到”object”。在JavaScript中， 数组其实是一个对象，只是拥有一些特殊的行为和能力。比如，数组拥有Array.prototype.length属性，它将会返回数组有多少个元素。数组也有一些特殊的方法，比如:Array.prototype.push()或Array.prototype.unshift()（可以参考JavaScript数组方法）。 区别数组和对象，我们可以使用Array.isArray()方法： 12Array.isArray( [1,2,3] ) // true Array.isArray( &#123; a: 1 &#125; ) // false typeof null是什么类型？1typeof null // "object" null的值从技术上来说和object和number一样，都是最基本的值，按理来说，null的类型也应该是”null”。然而并非如此，因为JavaScript最初设计时出了一点意外。 在JavaScript最初设计时，一个值有两个部分组成：它的类型标签和实际的值。有5个类型标签可以使用，而且对象类型的引用指向0。null的值始终指向NULL指针，它在大部分平台都是用0x00来表示。由于这种相似性，null就用过0类型标签来表示，所以符合对象的引用。 typeof class Foo {}是什么类型？1typeof class Foo &#123;&#125; // "function" 最后，我们讲一下类(Classes)。类在ES6中的介绍是：一个更好的语法为原型继承服务。在将类之前，我们先创建一个可继承的对象，我们要用到函数。 1234567function Dog() &#123; &#125;;Dog.prototype.bark = function() &#123; alert('woof!');&#125;const snoopy = new Dog();snoopy.bark(); //alert('woof!'); 使用类，我们可以用同样的方式创建一个类似的对象： 12345678class Dog &#123; bark() &#123; alert("woof!"); &#125;&#125;const snoopy = new Dog(); snoopy.bark() // alert("woof!") 然而，JavaScript的类只是一个被语法糖包裹的函数方法。实际上创建了一个同样的函数，但是作者的写法不同，只是看起来个简洁。这就是为什么typeof一个类，得到的仍然是”Function”。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流、函数防抖实现原理分析]]></title>
    <url>%2F2017%2F02%2F21%2F2017-02-21-debounce-function%2F</url>
    <content type="text"><![CDATA[之前翻译了一篇博客，里面有讲到这个，今天单独拎出来聊聊。 前言事件的触发权很多时候都属于用户，有些情况下会产生问题： 向后台发送数据，用户频繁触发，对服务器造成压力 一些浏览器事件:window.onresize、mousemove等，触发的频率非常高，会造成浏览器性能问题 如果你碰到这些问题，那就需要用到这些技术了。 我们先来解释一下函数节流(Throttling)和函数防抖(Debouncing)的区别: 我们上班、生活每天都需要坐电梯，用这个比喻再恰当不过了： 函数防抖和我们平时坐电梯差不多，如果有人进电梯（用户触发事件），那将在10秒钟后出发（执行程序），这时如果又有人进电梯了（用户在10秒内再次触发事件），我们又得等10秒再出发（重新计时）。 函数节流就比较直观了，有人进电梯，就开始计时，每10秒运送一次，如果没有人，则待机。 这两种策略具体使用场景还得看你的实际需求了，但是，只要理解了这个思想，接下来的就好办了。 函数节流(Throttling)函数节流的作用上面讲的很清晰了，接下来我们分析一下如何实现它： 123456789101112131415161718192021222324252627282930var throttle = function(fn, interval) &#123; //fn为要执行的函数，interval为延迟时间 var _self = fn, //保存需要被延迟执行的函数引用 timer, //定时器 firstTime = true; //是否第一次调用 return function() &#123; //返回一个函数，形成闭包，持久化变量 var args = arguments, //缓存变量 _me = this; if(firstTime) &#123; //如果是第一次调用，不用延迟执行 _self.apply(_me, args); return firstTime = false; &#125; if(timer) &#123; //如果定时器还在，说明上一次延迟执行还没有完成 return false; &#125; timer = setTimeout(function() &#123; //延迟一段时间执行 clearTimeout(timer); timer = null; _self.apply(_me, args); &#125;, interval || 500); &#125;;&#125;;//使用window.onresize = throttle(function() &#123; //你要执行的代码&#125;, 500); 其实函数节流和函数防抖的关键就是对setTimeout的运用，说个题外话，当你对setTimeout和setInterval内部的运作原理彻底了解后，你就是一名JS大神了。😝 函数防抖(Debouncing)我个人在开发中比较喜欢使用函数防抖策略，其实也说不上谁好，适应的场景不同。 我把注解也写在代码中了： 1234567891011121314151617181920212223242526function debounce(fn, interval, immediate) &#123; //fn为要执行的函数 //interval为等待的时间 //immediate判断是否立即执行 var timeout; //定时器 return function() &#123; //返回一个闭包 var context = this, args = arguments; //先把变量缓存 var later = function() &#123; //把稍后要执行的代码封装起来 timeout = null; //成功调用后清除定时器 if(!immediate) fn.apply(context, args); //不立即执行时才可以调用 &#125;; var callNow = immediate &amp;&amp; !timeout; //判断是否立即调用，并且如果定时器存在，则不立即调用 clearTimeout(timeout); //不管什么情况，先清除定时器，这是最稳妥的 timeout = setTimeout(later, interval); //延迟执行 if(callNow) fn.apply(context, args); //如果是第一次触发，并且immediate为true，则立即执行 &#125;;&#125;;//使用var myEfficientFn = debounce(function() &#123; //你要做的事&#125;, 250);window.addEventListener('resize', myEfficientFn); 上面代码有一个巧妙的设计：var callNow = immediate &amp;&amp; !timeout;，判断了timeout，如果存在，说明有定时器在运行，那就不是第一次执行，则不执行if(callNow)里的代码了。 总结这两个代码块是在开发中经常使用的，无论是为了适应需求还是优化性能，我们都没有理由不适用它们。 另外在jQuery的源码中也使用了这种技巧，即便在这个框架横行的时代，还是只有底层的知识能让我感到踏实。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单理解JavaScript中的柯里化和反柯里化]]></title>
    <url>%2F2017%2F02%2F15%2F2017-02-15-curring-uncurring%2F</url>
    <content type="text"><![CDATA[就像最早听到斐波拉切数列一样，第一次听到柯里化我也是懵逼的 前言本文旨在让大家简单理解柯里化和反柯里化，这里不做深入探究，只求能带大家装逼就好，看完还不懂你砍我。 我们先来简单了解一下他们的作用。 柯里化又称部分求值，字面意思就是不会立刻求值，而是到了需要的时候再去求值。如果看的懵逼，没事，看完整篇文章再回过头来看这里你就会豁然开朗。 反柯里化的作用是，当我们调用某个方法，不用考虑这个对象在被设计时，是否拥有这个方法，只要这个方法适用于它，我们就可以对这个对象使用它。 柯里化(curring)我们有这样一个场景，记录程序员一个月的加班总时间，那么好，我们首先要做的是记录程序员每天加班的时间，然后把一个月中每天的加班的时间相加，就得到了一个月的加班总时间。 但问题来了，我们有很多种方法可以实现它，比如最简单的： 123456789101112var monthTime = 0;function overtime(time) &#123; return monthTime += time;&#125;overtime(3.5); // 第一天overtime(4.5); // 第二天overtime(2.1); // 第三天//...console.log(monthTime); // 10.1 每次传入加班时间都进行累加，这样当然没问题，但你知道，如果数据量很大的情况下，这样会大大牺牲性能。 那怎么办？这就是柯里化要解决的问题。 其实我们不必每天都计算加班时间，只需要保存好每天的加班时间，在月底时计算这个月总共的加班时间，所以，其实只需要在月底计算一次就行。 下面的overtime函数还不是一个柯里化函数的完整实现，但可以帮助我们了解其核心思想： 12345678910111213141516171819202122var overtime = (function() &#123; var args = []; return function() &#123; if(arguments.length === 0) &#123; var time = 0; for (var i = 0, l = args.length; i &lt; l; i++) &#123; time += args[i]; &#125; return time; &#125;else &#123; [].push.apply(args, arguments); &#125; &#125;&#125;)();overtime(3.5); // 第一天overtime(4.5); // 第二天overtime(2.1); // 第三天//...console.log( overtime() ); // 10.1 柯里化的核心思想就是这样，看到这里你肯定已经懂了，至于真正的柯里化函数，网上有很多，大家可以去Google一下。 反柯里化(uncurring)反柯里化的的作用已经在前言说过了，这里讲下它的由来。 2011年JavaScript之父Brendan Eich发表了一篇Twitter，提出了反柯里化这个思想，下面这段代码是反柯里化的实现方式之一： 1234567Function.prototype.uncurring = function() &#123; var self = this; return function() &#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments); &#125;;&#125;; 我们先来看看上面这段代码有什么作用。 我们要把Array.prototype.push方法转换成一个通用的push函数，只需要这样做： 1234567var push = Array.prototype.push.uncurring();//测试一下(function() &#123; push(arguments, 4); console.log(arguments); //[1, 2, 3, 4]&#125;)(1, 2, 3) arguments本来是没有push方法的，通常，我们都需要用Array.prototype.push.call来实现push方法，但现在，直接调用push函数，既简洁又意图明了。 就和前言写的那样，我们不用考虑对象是否拥有这个方法，只要它适用于这个方法，那就可以使用这个方法（类似于鸭子类型）。 我们来分析一下调用Array.prototype.push.uncurring()这句代码时，发生了什么事情： 12345678910111213141516171819202122232425Function.prototype.uncurring = function() &#123; var self = this; //self此时是Array.prototype.push return function() &#123; var obj = Array.prototype.shift.call(arguments); //obj 是&#123; // "length": 1, // "0": 1 //&#125; //arguments的第一个对象被截去(也就是调用push方法的对象),剩下[2] return self.apply(obj, arguments); //相当于Array.prototype.push.apply(obj, 2); &#125;;&#125;;//测试一下var push = Array.prototype.push.uncurring();var obj = &#123; "length": 1, "0" : 1&#125;;push(obj, 2);console.log( obj ); //&#123;0: 1,1: 2, length: 2 &#125; 看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。 本文参考： JavaScript设计模式与开发实践 Currying in JavaScript Curried JavaScript functions 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Curring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定期更新 JavaScript技巧]]></title>
    <url>%2F2017%2F02%2F15%2F2017-02-15-javascript-skill%2F</url>
    <content type="text"><![CDATA[JavaScript技巧，偶尔更新。 计算数组的极值1234567891011function smallest(array)&#123; return Math.min.apply(Math, array); &#125; function largest(array)&#123; return Math.max.apply(Math, array); &#125; smallest([0, 1, 2.2, 3.3]); // 0largest([0, 1, 2.2, 3.3]); // 3.3 数组排序1234567[14.3, 8, 1, 64].sort(function(a, b) &#123; return a - b;&#125;);//[1, 8, 14.3, 64]//从大到小排序就是 b - a 迭代arguments1234567891011function useCall() &#123; [].forEach.call(arguments, function(val, key) &#123; console.log(key, val) &#125;);&#125;useCall('Bob Dylan', 'Bob Marley', 'Steve Vai');//0 "Bob Dylan"//1 "Bob Marley"//2 "Steve Vai" 将arguments转为数组123function transformToArray(arg)&#123; return Array.prototype.slice.call(arg);&#125; Array.prototype.forEach()第二个参数 参考：MDN 12345678910var coder = &#123; name: 'Shock', friends: ['Rocky', 'Bob'], logHiToFriends:function()&#123; 'use static' this.friends.forEach(function(friend)&#123; console.log(this.name+ ' say hi to '+ friend); &#125;,this)//注意这个this，如果不添加这个参数，你可以猜测会发生什么 &#125;&#125; 随机生成字母和数字组合的字符串1234Math.random().toString(36).substr(2);//un80usvvsgcpi0rffskf39pb9//02aoe605zgg5xqup6fdclnb3xr//ydzr1swdxjg3yolkb95p14i 使用IIFE解决循环问题unexpected: 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 输出数值 "10" 十次&#125;); expected: 12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value) &#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func) &#123; func(); // 从 0 到 9 依次输出&#125;); 使用let解决循环问题这是let独有的特性(参考) 1234567891011var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 从 0 到 9 依次输出&#125;) 判断两个小数是否相等123456789101112131415161718//因为javascript数字通常被输入为十进制的浮点数，但内部却被表示为二进制，所以计算结果会有偏差：0.1 + 0.2 //0.300000000000000040.1 + 1 - 1 //0.100000000000000090.1 + 0.2 === 0.3 //false//所以我们不应该直接比较非整数，而是取其上限，把误差计算进去//这样一个上限称为 machine epsilon，双精度的标准epsilon值是2^-53const EPSILON = Math.pow(2, -53); //1.1102230246251565e-16function epsEqu(x,y) &#123; return Math.abs(x - y) &lt; EPSILON;&#125;epsEqu(0.1+0.2, 0.3) //true Math.round函数的坑12345678Math.round(-3.2) //-3Math.round(-3.5) //-3(这个就奇怪了)Math.round(-3.8) //-4//其实，Math.round(x)等同于：Math.floor(x + 0.5) 巧用||和&amp;&amp;12345var bar = $ || 233;//如果$存在，则把$赋值给bar；如果$不存在，则把233赋值给bar$ === undefined &amp;&amp; (window.$ = jQuery); //如果$不存在,则把jQuery赋值给window.$；如果$存在，则不执行后面的表达式 使用break + labels退出循环123456789101112function findNumber(arr)&#123; loop:&#123; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i]%2 == 0)&#123; break loop;//表示退出loop区块 &#125; &#125; console.log(arr);//这句代码是不会执行的，如果上面只是break，for循环之后的代码还是会执行 &#125;&#125;findNumber([1,3,5,6]); 简单实现合并对象123456789101112131415function merge(root)&#123; for (var i = 1; i &lt; arguments.length; i++) &#123; for (var key in arguments[i]) &#123; if (arguments[i].hasOwnProperty(key)) &#123; root[key] = arguments[i][key]; &#125; &#125; &#125; return root;&#125;var merged = merge( &#123;name:'Shock'&#125;, &#123;city:'Shenzhen'&#125;)//&#123;name:'Shock',city:'Shenzhen'&#125; 理解map和parseInt12345['1','2','3'].map(parseInt);//[1, NaN, NaN]['1','2','3'].map(function(x)&#123;return parseInt(x,10)&#125;);//[1, 2, 3] 上传图片预览功能12&lt;input type="file" name="file" onchange="showPreview(this)" /&gt;&lt;img id="portrait" src="" width="70" height="75"&gt; 12345678910function showPreview(source) &#123; var file = source.files[0]; if(window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function(e) &#123; document.getElementById("portrait").src = e.target.result; &#125;; fr.readAsDataURL(file); &#125;&#125; 微信内部修改document.title12345678910111213141516function setTitle(title) &#123; document.title = title; if (/ip(hone|od|ad)/i.test(navigator.userAgent)) &#123; var i = document.createElement('iframe'); i.src = '/favicon.ico'; i.style.display = 'none'; i.onload = function() &#123; setTimeout(function()&#123; i.remove(); &#125;, 9) &#125; document.body.appendChild(i); &#125;&#125;setTitle("要修改的标题"); 快速克隆一个对象12345678910111213141516171819202122var Rocker = function(name, age)&#123; this.name = name, this.age = age&#125;var shock = new Rocker('Shock', 24);shock.age = 99;var cloneShock = Object.create(shock);cloneShock.name // "Shock"cloneShock.age // 99//在不支持ES5的浏览器下，实现create方法如下：Object.create = Object.create || function(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125; 判断一个值是否是对象123456function isObject(value)&#123; return value === Object(value);&#125;isObject(&#123;&#125;); // trueisObject(123); // false 为构造器模拟apply功能1234567891011121314if(!Function.prototype.construct)&#123; Function.prototype.construct = function(argArray)&#123; if(!Array.isArray(argArray))&#123; throw new TypeError("Arguments must be an array"); &#125; var constr = this; var nullaryFunc = Function.prototype.bind.apply( constr,[null].concat(argArray)); return new nullaryFunc(); &#125;&#125;//使用:Date.construct([2017, 02, 14]); // Tue Mar 14 2017 00:00:00 GMT+0800 (CST) 防止高频调用的debounce函数123456789101112131415161718192021222324//immediate参数判断是否立即执行function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if(!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if(callNow) func.apply(context, args); &#125;;&#125;;//使用var myEfficientFn = debounce(function() &#123; //你要做的事&#125;, 250);window.addEventListener('resize', myEfficientFn); 设定时间/频率循环检测函数12345678910111213function poll(fn, callback, err, timeout, interval) &#123; var startTime = (new Date()).getTime(); var pi = window.setInterval(function() &#123; if(Math.floor(((new Date()).getTime() - startTime) / 1000) &lt;= timeout) &#123; if(fn()) &#123; callback(); &#125; &#125; else &#123; window.clearInterval(pi); err(); &#125; &#125;, interval)&#125; 禁止重复调用、只允许执行一次的once 函数12345678910111213141516171819function once(fn, context) &#123; var result; return function() &#123; if(fn) &#123; result = fn.apply(context || this, arguments); fn = null; &#125; return result; &#125;&#125;//使用var canOnlyFireOnce = once(function() &#123; console.log('只触发一次！');&#125;)canOnlyFireOnce(); // "只触发一次"canOnlyFireOnce(); // undefined 获取一个链接的绝对地址12345678910111213var getAbsoluteUrl = (function() &#123; var a; return function(url) &#123; if(!a) a = document.createElement('a'); a.href = url; return a.href; &#125;;&#125;)();//使用getAbsoluteUrl("/something"); //https://rockjins.github.io/something uncurring实现方法之一123456789101112131415Function.prototype.uncurring = function() &#123; var self = this; return function() &#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments); &#125;;&#125;;//使用var push = Array.prototype.push.uncurring();(function() &#123; push(arguments, 4); console.log(arguments); //输出：[1, 2, 3, 4]&#125;)(1, 2, 3) 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some picture about Johnny Depp & Marilyn Manson]]></title>
    <url>%2F2017%2F02%2F15%2F2017-02-15-depp-manson%2F</url>
    <content type="text"><![CDATA[Two paranoid men. 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』一些 JavaScript 优化的细节]]></title>
    <url>%2F2017%2F02%2F13%2F2017-02-13-tiny-javascript-optimizations%2F</url>
    <content type="text"><![CDATA[Read the original 前言优化客户端JavaScript代码常常是不值得的，因为这会失去代码可读性。如果你的APP运行缓慢，你可以考虑是否能优化请求，减少对DOM的操作，尽量少的操local storage，或者牺牲其它的来换取性能。几乎没有足够的数据认为客户端需要让代码同步运行速度更快。我认为接下来的代码十分具有可读性，如果你也需要，为什么不使用它呢？ 递归尾调用(Recursive tail calls)在下面例子中，函数每次执行都会创建一个新的栈(维持新添加的环境)。所以，如果参数x:5000，那就会创建5000个栈。 123456function foo(x) &#123; if (x &lt; 0) &#123; return 1; &#125; return 1 + foo(x-1);&#125; 如果使用一个累加数，就不会有新添加的环境需要被维持，所以返回的栈可以代替当前函数的栈。 123456function foo(x, accumulated) &#123; if (x &lt; 0) &#123; return 1; &#125; return foo(x-1, accumulated + 1);&#125; 使用逻辑表达式与C语言不同，在JavaScript中逻辑表达式可以用来做操作运算，而不只是判断真假。这意味着我们可以写出像下面一样简单的代码： 123456function foo(x) &#123; if (!x) &#123; return null; &#125; return x.y;&#125; 优化后的版本： 123function foo(x) &#123; return x &amp;&amp; x.y;&#125; 散列法 &gt; 迭代switch语句可以让返回的数据在结构中重现。但通常，我们只需要查找和比较一个文件，使用散列法会比迭代快很多。 123456789101112131415function iterating(action) &#123; switch (action.type) &#123; case 'a': // do something with action.data ... return; case ... case 'z': ... return; default: return; &#125;&#125;iterating(&#123;type: 'z', data: 'asdf'&#125;); 迭代26个元素。 123456789101112const lookupTable = &#123; 'a': (data) =&gt; &#123;...&#125;, ... 'z': (data) =&gt; &#123;...&#125;&#125;function hashing(action) &#123; const handler = lookupTable[action.type]; if (handler) &#123; return handler(action.data); &#125;&#125; 一个比较和一个查找。 当然，这适用于任何可迭代的元素(arrays,strings,etc)，但switch也有它的一些优势。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』3个原因让我像躲避瘟疫一样避免使用JS匿名函数]]></title>
    <url>%2F2017%2F02%2F13%2F2017-02-14-three-reasons-i-avoid-anonymous-js-functions-like-the-plague%2F</url>
    <content type="text"><![CDATA[Read the original 前言无论何时阅读代码，你一定会看到匿名函数。有时它们被称为lambdas，有时被称为匿名函数（anonymous functions），但不管怎样，我认为他们是糟糕的。 如果你不知道什么是匿名函数，这里有一段引用： 匿名函数是一个可以在运行时动态声明的函数。之所以称为匿名函数是因为：他们没有像普通函数一样被赋予名字(name)。 ——Helen Emerson, Helephant.com 它们看起来有点像这个： 12345function() &#123; ... code ... &#125;OR（args） =&gt; &#123; ... code ... &#125; 下面我会举一些例子给你，实际上，只有在非用不可的情况下才会使用匿名函数。它们不是你的首选，并且你要知道为什么。一旦你这么做了，你的代码会更简洁、容易去阅读，BUG也更容易被捕获，让我们看看这3个避免使用它们的原因吧！ 堆栈跟踪你终于写完了代码，无论你有多擅长编码，当你运行代码时，总会有一些报错。有些错误很容易被捕获，但有时并不是这样。 如果错误很容易被捕获到，好的，那说明你知道他们错在哪！为此，我们使用所谓的堆栈跟踪，如果你对堆栈跟踪一点都不了解，Google给了我们很好的介绍。 假设我们有一个很简单的项目: 1234567function start () &#123; (function middle () &#123; (function end () &#123; console.lg('test'); &#125;)() &#125;)()&#125; 但看起来我们做了一些愚蠢得难以置信的事，就像拼错console.log。在我们这个小项目中，这没什么大不了的。但也许这是一个巨型项目中的一个片段，有大量的模块与它相互依赖。最重要的是，让我们假装你没有烦这种愚蠢的错误。那个初级开发者在他准备离开度假的前一天，把它推到了仓库中！ 现在，我们将去跟踪错误。根据我们精确的命名函数，我们得到的堆栈跟踪像下面这样： 幸好你给函数命名了，初级开发者！现在，我们能轻松的跟踪到这个BUG。 但是…一旦我们修复了它，又会出现新的BUG。这时，就要请出更高级的开发者了。他们知道如何使用匿名函数，并大量的使用在他们的代码中。结果是，他们发现了一个BUG，我们去跟踪BUG。 他们的代码： 1234567(function () &#123; (function () &#123; (function () &#123; console.lg('test'); &#125;)(); &#125;)();&#125;)(); 多令人惊讶，这个高级开发者也忘了怎么拼写console.log！这是一个偶然吗？！告诉你一个悲痛的消息，他们没有给函数命名。 控制台会展示什么给我们？ 没事…我们还有行号提示？ 在这个例子中，我们好像有7行代码。如果我们在处理一个巨大的代码库？如果每行有10k的代码?如果行号相差很远？如果代码被压缩了、没有map文件、行号提示几乎是没用的？ 我认为你可以非常容易的回答这些问题。答案是：你会度过糟糕的一天。 可读性看吧，我知道你不服气。你仍然爱着匿名函数，而且你永远也不会有BUG。抱歉，我忘了告诉你如何写出完美的代码。让我们来看看这点！ 检查下面两个不同的代码示例: 12345678910111213141516171819202122232425function initiate (arguments) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; if (arguments) &#123; return resolve(true); &#125; return resolve(false); &#125; catch (e) &#123; reject(e); &#125; &#125;);&#125;initiate(true) .then(res =&gt; &#123; if (res) &#123; doSomethingElse(); &#125; else &#123; doSomething(); &#125; ).catch(e =&gt; &#123; logError(e.message); restartApp(); &#125; ); 这是一个人为的例子，但我认为你能get到那个点。我们有一个方法，它返回一个Promise对象，我们用这个对象去管理可能返回的不同请求。 你或许认为这个代码阅读起来不太难，但我认为它能写的更好。 如果我们摆脱所有匿名函数，结果会如何？ 123456789101112131415161718192021222324252627function initiate (arguments) &#123; return new Promise(checkForArguments);&#125;function checkForArguments (resolve, reject) &#123; try &#123; if (arguments) &#123; return resolve(true); &#125; return resolve(false); &#125; catch (e) &#123; reject(e); &#125;&#125;function evaluateRes (res) &#123; if (res) &#123; doSomethingElse(); &#125; else &#123; doSomething(); &#125;&#125;function handleError (e) &#123; logError(e.message); restartApp();&#125;initiate(true) .then(evaluateRes) .catch(handleError); 好了，让我们来屡清一下思路：这段代码比之前的要长，但我认为它比之前的可读性高得多！我们使用了非常棒的命名函数而不是匿名函数。只要我们看到命名函数，它的名字就会暗示我们接下来会发生什么。它消除了我们在阅读代码时的心理障碍。 这也有利于独立问题。不仅仅是创建方法，传递参数，运行逻辑，在第二个例子中，传递参数给then和catch，我们可以很清楚的知道函数中的每一处都发生了什么。 时间不多了，否则我要让你信服这些代码可以更加易读。也许你任然不相信，那尝试看看第三个论据… 可重用性你有注意到最后一个例子吗？所有函数都是可以互相调用的！ 当你使用匿名函数时，它们很难遍布你的程序。重用代码可以降低能耗，你也不用一遍遍写重复的代码了。还有大家都知道的一点，代码越少，引入BUG的几率越小，而且用户可以加载更少的资源。共赢的局面！ 相反的，命名函数可以在它的整个作用域中使用，而不需要像变量一样四处传递。你写的代码会很自然的更具重用性，因为，你可以重用他们！ 匿名函数好吗？是的。我必须承认，有时它们也是最好的选择！ 123456const stuff = [ &#123; hide: true, name: 'justin' &#125;, &#123; hide: false, name: 'lauren' &#125;, &#123; hide: false, name: 'max' &#125;,];const filteredStuff = stuff.filter(s =&gt; !s.hide); 这个匿名函数s =&gt; !s.hide小而简洁，它不会污染其它地方，也不会用在其它地方。它会在stuff.filter的堆栈跟踪中显示。如果你需要重用它，最好重用整个语句： 123function filterByHide (array) &#123; return array.filter(item =&gt; !item.hide);&#125; 有时你需要包裹你所有的代码在一个匿名函数中，以保证全局作用域不被污染。 123(() =&gt; &#123; ... your code here ...&#125;)(); 顶级匿名函数不会影响到堆栈跟踪。代码重用是不会造成伤害的，因为代码重用的全部目的就是保持方法被包含。 我相信还有其他地方适合使用匿名函数，在评论中分享一下吧！ 感谢阅读，离开这里后，停止写匿名函数吧！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』JavaScript 函数式编程]]></title>
    <url>%2F2017%2F02%2F11%2F2017-02-11-functional-programming%2F</url>
    <content type="text"><![CDATA[Read the original 前言函数式编程与我们以往的编程习惯有许多不同。这篇文章举了一些JavaScript的例子，介绍了函数式编程中重要的概念。附加的文章会让你更深入的了解JavaScript中的函数式编程。 本文源码可以在GitHub上找到，放在jsFunctionalProgramming仓库中。 我要感谢Csaba Hellinger的支持和投入，在他的帮助下我才完成这篇文章。 PART 1函数式编程由Lambda Calculus演化而来，它是一个抽象数学的函数表述，我们将思考怎么把它运用在现实中。 函数式编程是声明式编程的范式。 为什么要使用函数式编程？函数式编程有以下具体特性： 避免状态改变（可变的数据） - 函数式编程的特性之一就是：函数在应用中不会改变状态，它们(functions)宁愿从之前的状态之上创建一个新的状态。 函数声明 vs 函数表达式 - 在函数式编程中，我们定义和描述函数就像数学中的一个方法声明。 幂等性 - 这意味着我们用相同的参数调用一个函数(不管任何时刻)它都会返回相同的结果，这也可以避免状态的改变。 这三个特性咋一看似乎并没有什么意义，但如果我们更深入的分析，发现在以下三种情况下使用函数式编程能充分发挥这三个特性： 并行的代码执行 - 因为函数式编程有幂等性和避免状态改变的特性，用函数方法编写代码会让并行更容易，因为不会出现同步问题。 简明、简洁的代码 - 因为函数式编程使用方法声明的方式，代码不会像面向过程编程一样，有额外的算法步骤。 不同的编程思想 - 一旦你真正使用了一门函数式编程语言，你会拥有一种新的编程思想，当你构建应用时也会有新的点子。 f(x) === J(s)javascript 是一门真正的（纯粹的）函数式编程语言吗？ 不！JavaScript并不是一门纯粹的函数式编程语言… 第一型对象 - 函数它可以很好的运用在函数式编程中，因为函数是第一性对象。如果在一门编程语言中，函数和其他类型一样，那么这门语言中的函数就是第一型对象。举个例子，函数可以作为参数传递给其他函数，也可以赋值给变量。 我们将检查一些函数是否是第一型对象，但是在这之前，我们先构建一个代码块，我们将像真正的函数式语言一样使用JavaScript。 在大部分纯函数式编程语言中(Haskell, Clean, Erlang)，它们是没有for或者while循环的，所以循环一个列表需要用到递归函数。纯函数式编程语言有语言支持和最好的列表推导式和列表串联。 这里有一个函数实现了for循环，我们将在接下来的代码中用到它，但是你也将看到它在JS中的局限性，因为尾部调用优化并没有被广泛的支持，但以后会好起来的。 1234567891011121314151617181920212223function funcFor(first, last, step, callback) &#123; // //递归inner函数 // function inner(index) &#123; if((step &gt; 0 &amp;&amp; index &gt;= last) || (step &lt; 0 &amp;&amp; index &lt; last)) &#123; return; &#125; callback(index); // //接下来进行尾部调用 // inner(index + step); &#125; // //开始递归 // inner(first);&#125; inner函数包含了对停止递归的管理，它传入参数index去调用callback，再递归调用inner(index + step)确保循环传递到下一步。 递归是函数式编程的一个重要方面。 现在，让我们看看真正的函数式编程： 123456function applyIfAllNumbers(items, fn) &#123; if(areNumbers(items)) &#123; return funcMap(items, fn); &#125; return [];&#125; applyIfAllNumbers函数的目的是调用fn函数，并把items中的每个数字作为参数传入，但前提是只有在items数组中都是数字的情况下才去调用。 下面是验证器函数： 123456789101112function areNumbers(numbers) &#123; if(numbers.length == 0) &#123; return true; &#125; else &#123; return isNumber(number[0]) &amp;&amp; areNumbers(numbers.slice(1)); &#125;&#125;function isNumber(n) &#123; return isFinite(n) &amp;&amp; +n === n;&#125; 这段代码简单明了，如果参数是一个数字，isNumber函数返回true，否则返回false。areNumbers函数使用isNumber函数判断numbers数组中是否全是数字（再提醒一次，递归常常被用来实现这种逻辑）。 另一个例子是applyForNumbersOnly： 1234function applyForNumbersOnly(items, fn) &#123; let numbers = filter(items, isNumber); return funcMap(numbers, fn);&#125; 这样写甚至更简洁： 123function applyForNumbersOnly(items, fn) &#123; return funcMap(filter(items, isNumber), fn);&#125; applyForNumbersOnly调用fn方法仅仅是为了收集items中的数字。 funcMap函数在函数式编程中重现了著名的map函数，但是这里我借助了funcForEach函数来创建它： 12345678910111213function funcForEach(items, fn) &#123; return funcFor(0, items.length, 1, function(idx) &#123; fn(items[idx]); &#125;);&#125;function funcMap(items, fn) &#123; let result = []; funcForEach(items, function(item) &#123; result.push(fn(item)); &#125;); return result;&#125; 最后还剩filter函数，我们再一次使用递归来实现过滤的逻辑。 1234567891011121314function filter(input, callback) &#123; function inner(input, callback, index, output) &#123; if (index === input.length) &#123; return output; &#125; return inner( input, callback, index + 1, callback(input[index]) ? output.concat(input[index]) : output; ); &#125; return inner(input, callback, 0, []);&#125; JS中的尾调用优化(TCO)在EcmaScript 2015 TCO文档中有一些用例的定义，这门语言不久就将支持尾调用优化了。最关键的一点就是在你的代码中使用use strict模式，否则JS不能支持尾调用优化。 由于没有内置方法来检测浏览器是否支持尾调动优化，以下代码实现了这个功能： 123456789101112"use static"function isTCOSupported() &#123; const outerStackLen = new Error().stack.length; //inner函数的name长度一定不能超过外部函数 return (function inner() &#123; const innerStackLen = new Error().stack.length; return innerStackLen &lt;= outerStackLen; &#125;());&#125;console.log(isTCOSupported() ? "TCO Available" : "TCO N/A"); 这里有一个重现Math.pow函数的例子，它能从EcmaScript 2015的TCO中获益。 这个pow函数的实现使用了ES6默认参数，让它看上去更简洁。 1234567891011function powES6(base, power, result=base) &#123; if (power === 0) &#123; return 1; &#125; if(power === 1) &#123; return result; &#125; return powES6(base, power - 1, result * base);&#125; 首先要提醒以下，powES6函数有三个参数而不是两个。第三个参数是计算后的值。我们随身携带return是为了实现让我们的递归调用变成真正的尾调用，让JS可以使用它的尾调用优化技术。 万一我们不能使用ES6的特性，那么我们不推荐使用递归去实现pow函数，因为这门语言还没有提出有关递归的优化，这样实现起来就很复杂了： 1234567891011121314function recursivePow(base, power, result) &#123; if (power === 0) &#123; return 1; &#125; else if(power === 1) &#123; return result; &#125; return recursivePow(base, power - 1, result * base);&#125;function pow(base, power) &#123; return recursivePow(base, power, base);&#125; 我们把递归计算放在了另一个recursivePow函数中，这个函数有三个参数，就像powES6函数一样。使用一个新函数并把base作为参数传递给它，以此实现ES6中的默认参数逻辑。 在这个页面你可以查看TCO在不同浏览器和平台的支持情况。 目前只有Safari 10是完全支持TCO的浏览器(在写这篇文章时)，我将进行一些对于pow的测试，来看看它的表现。 测试递归调用我使用了powES6和pow函数来进行测试: 1234567891011121314151617181920212223242526272829303132333435"use strict";function stressPow(n) &#123; var result = []; for (var i=0; i&lt;n; ++i) &#123; result.push( pow(2, 0), pow(2, 1), pow(2, 2), pow(2, 3), pow(2, 4), pow(2, 5), pow(2, 10), pow(2, 20), pow(2, 30), pow(1, 10000), pow(2, 40), pow(3, 10), pow(4, 15), pow(1, 11000), pow(3.22, 125), pow(3.1415, 89), pow(7, 2500), pow(2, 13000) ); &#125; return result;&#125;var start = performance.now();var result_standard = stressPow(2500); var duration = performance.now() - start; console.log(result_standard); console.log(`Duration: $&#123;duration&#125; ms.`); 我在Chrome v55, Firefox v50, Safari v9.2 和 Safari v10上测试了以上代码。 小结根据上面的数据，我们得出Safari对递归函数的优化效率是最高的。Safari 10对尾调用的支持是最好的，速度比Chrome快了大约2.8倍。Firefox几乎和Safari 9.2 一样棒，这出乎了我的意料。 如果你很喜欢这篇文章，请点个赞哦。（译者注：话说好长啊，好累啊。） 让我们继续函数式! PART 2 也即将发出，关于高阶函数和例子，讲解如何编写函数式风格的代码。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』扩展运算符的6个重要用途]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-spread-operator%2F</url>
    <content type="text"><![CDATA[Read the original 前言由于ES6和Babel的出现，编写JavaScript代码变得难以置信的灵活，从新的语法到自定的编译器，像JSX。我变成了扩展运算符(Spread Operator)的超级粉丝，三个点就改变你编写JavaScript代码的方式。接下来的清单，列出了我在JavaScript中最喜欢怎样使用扩展运算符！ 1.不使用Apply去调用函数这一点我们叫它Function.prototype.apply，传递一个参数数组，调用一个函数，并把数组中的每一项拆分成单个参数传递给函数： 12345function doStuff (x, y, z) &#123; &#125;var args = [0, 1, 2];// 调用函数，传递参数doStuff.apply(null, args); 通过扩展运算符我们可以避免使用apply，只需简单的调用函数，并在参数数组前加上扩展运算符： 1doStuff(...args); 这让代码更简短、清晰，而且不需要无用的null！ 2.合并数组一直以来，有很多方法合并数组，但是扩展运算符给了我们全新的方法去实现合并数组： 12arr1.push(...arr2) // 把arr2合并到arr1的后面arr1.unshift(...arr2) //把arr2合并到arr1的前面 如果你想在数组内合并数组，你可以像下面这样做： 1234var arr1 = ['two', 'three'];var arr2 = ['one', ...arr1, 'four', 'five'];// ["one", "two", "three", "four", "five"] 比其他方法的语法更简单，还增加了位置的控制！ 3.复制数组复制数组是我们常常要做的工作，在过去，我们会使用Array.prototype.slice去实现，但现在我们可以使用扩展运算符去得到一个复制后的数组： 123var arr = [1,2,3];var arr2 = [...arr]; // 就像 arr.slice()arr2.push(4) 记住：数组仍通过指针得到，所以我们并没有复制数组本身，我们复制的只是一个新的指针。 4.把arguments或NodeList转为数组和复制数组十分类似，我们以前使用Array.prototype.slice去把NodeList和arguments转换成真正的数组，但现在我们可以使用扩展运算符去完成这个工作： 1[...document.querySelectorAll('div')] 你还可以让arguments在传递时就变成一个数组： 123var myFn = function(...args) &#123;//译者注：args等同于[...arguments]&#125; 别忘了，用Array.from也能达到效果。 5.使用Math函数扩展运算符把数组”扩展”成一个个不同的参数是理所当然的，所以，可以在任何函数参数上进行扩展，而且它能接收任意多个参数： 12let numbers = [9, 4, 7, 1];Math.min(...numbers); // 1 在Math对象的成员方法上使用扩展运算符是一个完美的例子，而且只需要传递一个参数。 6.有趣的结构赋值结构赋值是一个十分有趣的实践，我在自己的React项目中大量的使用了这种技巧，还有在其他的Node.js项目中。你可以使用扩展运算符配合其他运算符一起，从变量中提取有用的信息，就像这样： 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(x); // 1console.log(y); // 2console.log(z); // &#123; a: 3, b: 4 &#125; 剩下的属性会自动分配给拥有扩展运算符的变量！ 总结ES6不仅让JavaScript更复杂，也让它更有趣了。现代浏览器都支持新的ES6语法，所以，如果你还没有花时间去了解并使用它，你清楚你该怎么做。如果你要开始使用ES6，一定要来看看我的这篇文章Getting Started with ES6。不管怎样，扩展运算符都是JavaScript中一个非常有用的特性，你应该已经清楚的意识到了！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』有趣的Console对象]]></title>
    <url>%2F2017%2F02%2F08%2F2017-02-08-fun-with-console-object%2F</url>
    <content type="text"><![CDATA[Read the original Console对象提供了接口去操作浏览器的调试控制台（像火狐浏览器中的控制台）。它在不同浏览器中实现细节不同，但也有其通用的特性。Console - Web API 接口 | MDN 下面列举了一些你可能不知道的Console对象的特性：(译者注：以下例子都可在控制台直接运行) 1.清空控制台使用console.clear()指令清空你的控制台。 2.输出样式你可以使用%c指令给你的输出指定样式: 1console.log('%c Make console greate again!', 'font-size:50px; background:red;') 3.显示表格样式的数据使用console.table(object)，提供一个对象，让它像表格一样显示： 让我们来试试： 123persons = [ &#123; name: 'Hien Vuong', city: 'Ho Chi Minh' &#125;, &#123; name: 'Donald Trump', city: 'New York' &#125;]console.table(persons) 4.分组输出使用console.group(message)和console.groupEnd()指令，用下拉列表的形式分组输出全部日志。 让我们用上面的persons对象试试： 123456persons.forEach(p =&gt; &#123; console.group(); console.log(`This is $&#123;p.name&#125;`); console.log(`He comes from $&#123;p.city&#125;`); console.groupEnd();&#125;); 这样敲代码多让人开心！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
        <tag>Console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』JavaScript技术面试时要小心的三个问题]]></title>
    <url>%2F2017%2F01%2F26%2F2017-01-26-interviews-javascript%2F</url>
    <content type="text"><![CDATA[原文链接：3 JavaScript questions to watch out for during coding interviews（需要梯子访问） 前言JavaScript是所有现代浏览器的官方语言。同样的，JavaScript面试题出现在各种各样的面试中。 这篇文章不是讲述JavaScript最新的库、日常的开发实践，或是ES6的新功能。当然了，上面说的这3点经常出现在JavaScript的面试中。我自己也曾经问过面试者这些问题，我的朋友告诉我，他们同样也是。 当然，你去面试前不能只准备上面提到的3点，这里有许多的方法让你能够更好的面对即将到来的面试。 但是，接下来的这3个问题，面试官可能会根据你的回答，去判断你对JavaScript和DOM的了解程度。 所以，现在开始吧！请注意，我们在接下来的例子中将使用原生JavaScript，因为你的面试官可能想看看在没有第三方库的情况下，比如jQuery，你对JavaScript和DOM的理解程度。 问题 #1: 事件委托当构建一个程序时，有些时候你需要监听按钮、文本、图片的事件，因为当用户与界面元素发生互动时，你需要执行一些动作。 如果我们拿到一个简单的待办事项列表，就像下面例子中这样，面试官可能会告诉你，当用户点击其中一个列表项时，我们需要执行一些动作。面试官希望你用JavaScript实现这个功能，假设HTML代码如下： 123456&lt;ul id="todo-app"&gt; &lt;li class="item"&gt;Walk the dog&lt;/li&gt; &lt;li class="item"&gt;Pay bills&lt;/li&gt; &lt;li class="item"&gt;Make dinner&lt;/li&gt; &lt;li class="item"&gt;Code for one hour&lt;/li&gt;&lt;/ul&gt; 你也许会像下面这样去给这些元素绑定事件监听： 12345678910111213document.addEventListener('DOMContentLoaded', function() &#123; let app = document.getElementById('todo-app'); let items = app.getElementsByClassName('item'); // 给每个列表项绑定事件监听器 for (let item of items) &#123; item.addEventListener('click', function() &#123; alert('you clicked on item: ' + item.innerHTML); &#125;); &#125;&#125;); 虽然实现了功能，但问题是我们给每个列表项都单独绑定了事件监听。现在只有4个元素，没问题，但是如果有10000个待办事项呢(程序可能还有其他事情要做)？接下来你会创建10000个事件监听函数绑定要每个DOM元素上，这是十分低效的。 在面试时，最好问问面试官用户可以输入的最大元素数量。如果数量小于10个，上面的例子可以很好的运行。但是如果数量不受限制，你可能需要使用一个更有效率的解决办法。 如果你的应用有数百个事件监听，更有效率的解决办法是：把事件监听绑定在包裹这些元素的容器上，当元素被点击时，我可以得到当前点击的确切元素。这种技巧叫事件委托，而且它比给每个元素绑定事件监听效率要高。 用事件委托的方式实现上面的功能： 12345678910111213document.addEventListener('DOMContentLoaded', function() &#123; let app = document.getElementById('todo-app'); // 把事件监听器绑定在它们的容器上 app.addEventListener('click', function(e) &#123; if (e.target &amp;&amp; e.target.nodeName === 'LI') &#123; let item = e.target; alert('you clicked on item: ' + item.innerHTML); &#125; &#125;);&#125;); 问题 #2: 在循环内使用闭包闭包问题常常在面试中被提出，面试官能通过它估算出你对JavaScript的熟悉程度，同时了解你对闭包是否熟悉。 闭包的精髓就是：在外部函数中可以读取到内部函数的作用域。闭包可以做这些事：创建私有变量、创建私有函数等。大多数关于闭包的面试题像这样： 循环一个数组，并在3秒后打印出每个数组元素的索引。 一个通常的实现方式像下面这样，但其实是错误的： 123456const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; setTimeout(function() &#123; console.log('The index of this number is: ' + i); &#125;, 3000);&#125; 如果运行上面代码你会发现，3秒后，每次循环输出的都是4，而不是期望的0,1,2,3。 真正的去理解为什么会发生这些，它会帮助你更好的认识JavaScript，因为你也不知道面试官会出怎样确切的题测试你。 出现上面现象的原因是:setTimeout会创建一个函数(就是闭包)，它可以读取到外部作用域，每个循环都包含了索引i。函数在3秒后执行，它打印出外部作用域中i的值，在循环结束后i等于4，因为它的循环周期经历了0,1,2,3,4，最终在i为4时停止。 这里有几种正确的方法去解决这个问题，下面列举两种： 12345678910const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; // 通过传递变量 i // 在每个函数中都可以获取到正确的索引 setTimeout(function(i_local) &#123; return function() &#123; console.log('The index of this number is: ' + i_local); &#125; &#125;(i), 3000);&#125; 123456789const arr = [10, 12, 15, 21];for (let i = 0; i &lt; arr.length; i++) &#123; // 使用ES6的let语法，它会创建一个新的绑定 // 每个方法都是被单独调用的 // 详情请移步至: http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads setTimeout(function() &#123; console.log('The index of this number is: ' + i); &#125;, 3000);&#125; 问题 #3: 函数防抖（Debouncing）有些浏览器事件可以在很短的时间内执行多次，就像改变浏览器窗口尺寸和滚动页面。如果你绑定一个事件去监听窗口的滚动，用户快速连续的滚动页面，这个事件可能会在3秒内被触发几千次。这可能会导致很严重的性能问题。 如果你们在面试中讨论构建一个应用，谈到类似滚动、改变窗口尺寸或键盘按下的事件时，一定会提及函数防抖(Debouncing)、函数节流（Throttling）去优化页面速度和性能。一个真实的案例，来自guest post on css-tricks: 在2011年，一个问题在Twitter上被提出：当你滚动Twitter feed时，它会十分缓慢且迟钝。John Resig就这个问题发布了一篇博客，它解释了直接绑定函数到滚动事件上是多么糟糕和昂贵的事。 函数防抖是解决这个问题的一种方式，通过限制函数被调用的次数。一个正确实现函数防抖的方法是：把多个函数放在一个函数里调用，隔一定时间执行一次。这里有一个使用原生JavaScript实现的例子，用到了作用域、闭包、this和定时时间： 1234567891011121314151617// debounce函数用来包裹我们的事件function debounce(fn, delay) &#123; // 持久化一个timer let timer = null; // 闭包可以获取到timer return function() &#123; // 通过函数获取到作用域和参数列表 // 通过 'this' 和 'arguments' let context = this; let args = arguments; // 如果事件被触发，清除timer并重新开始计时 clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 当这个函数绑定在一个事件上，只有经过一段指定的时间后才会被调用。 你可以像这样去使用这个函数： 12345678// 当用户滚动时函数会被调用function foo() &#123; console.log('You are scrolling!');&#125;// 在事件触发的两秒后，我们包裹在debounce中的函数才会被触发let elem = document.getElementById('container');elem.addEventListener('scroll', debounce(foo, 2000)); 函数节流是另一个类似函数防抖的技巧，除了使用等待一段时间再调用函数的方法，函数节流还限制固定时间内只能调用一次。所以一个事件如果在100毫秒内发生10次，函数节流会每2秒调用一次函数，而不是100毫秒内全部调用。 想了解更多关于函数防抖和函数节流的信息，下面的文章和教程可能会帮到你： 在JavaScript中使用函数防抖和函数节流 函数节流和函数防抖的区别 函数节流和函数防抖的例子 节流函数的调用(Remy Sharp’s blog) 译者注：之前听朋友讲过这个例子，我就很清晰的分辨了两者的区别： 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。 throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。 debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
        <tag>Interviews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』JavaScript疲劳症]]></title>
    <url>%2F2017%2F01%2F22%2F2017-01-22-javascript-fatigue%2F</url>
    <content type="text"><![CDATA[原文链接：https://medium.freecodecamp.com/javascript-fatigue-fatigue-66ffb619f6ce#.khis636n3 宇宙没有义务让你觉得它对你有意义。 – Neil deGrasse Tyson 是的，JavaScript的开发越来越复杂了。 是的，JavaScript将会继续变得越来越复杂。 互联网是一个复杂的领域。我们最终没有去做我们本应该去做的那些事情。 结果就是，JavaScript工具和许多和它有关的，都在迅速的发展。 如果它的发展过程让你感到压力倍增，阅读下面这篇文章让你放松一下吧： 在 2016 年学 JavaScript 是一种什么样的体验 下面这篇文章模仿上面的文章的风格，讲述开发环境配置是一件多么复杂的事： 容器时代，难道这就是我们想要的未来？ 但是不要忽略一个显而易见的问题，为什么JavaScript开发会如此复杂？因为web开发其本身就是复杂的。 (上图为：CSS滤镜效果浏览器兼容性 来自caniuse.com) 我们尝试去构建一个web应用，让它在不同的浏览器上都能正确的运行，在上千个不同的设备上看上去还不错，为了满足那些缺乏耐心的乘地铁的上班族，它加载必须足够快，它还要尽可能的让盲人能使用它。 与此同时，web开发者在处理无处不在的安全漏洞。 我们在游说管理人员放弃糟糕的实现方式。(现在常见的网页体积大小都大于1993年的游戏DOOM。) 我们去适应基于浏览器的广告屏蔽插件，因为它很多时候阻拦的并不是广告。 这里有很多可行的方案去达成我们所有的目的。这时，巨大的生态圈工具开始出现，它从不同的方面去解决不同的问题。 Extreme Programming（极限编程）的作者早在1983年说过： 让它工作，让它正确，让它快速。 – Kent Beck 好吧，在过去的20多年里，我们关注web开发中遇到各种问题的解决办法。 最后，JavaScript开发者终于有了自己的生态圈，还不止于此，对此我们感到高兴。 上图来自：2016年优秀的javascript站点截图 开发工具还一个快速的发展就是，它不再受控于Apple或Microsoft操作系统。 大家共同的努力让它突然之间变得正确和迅速。 这个漫画完美的诠释了存在于我们身上的”JavaScript疲劳症”,Dr. Axel Rauschmayer(Speaking JavaScript的作者) 让”JavaScript疲劳症”更早的到来了。 当在各种各样的工具中进行选择时，我们尽可能的提出建设性的意见。我们告诉新人远离那些未经验证的工具。我们告诫他们，成为一个开发人员很难，而且工作很大部分时间是在学习使用新的工具。 如果你是个JavaScript新手，记住，所有这些新工具都是好的东西。开源的npm生态圈也是一个非常好的东西。 他们会让你更幸福，成为一个更强大的开发者。 他们会帮助你更好的服务你的终端用户。 如果你也是许多”JavaScript疲劳症”患者中的一员，你担心自己可能会坚持不下去，那么就想想下面这句话： 如果你正在走向地狱，那就继续前进。 – Winston Churchill 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角函数学习历程记录]]></title>
    <url>%2F2017%2F01%2F19%2F2017-01-19-trigonometric-function%2F</url>
    <content type="text"><![CDATA[是时候捡起来了 别那么在乎别人的眼光 素材来自：LZRspace 1.已知斜边为20，邻边为10，求角x. 答：Math.acos(10/20)/(Math.PI/180); 2.已知C是45°，斜边为20，求其邻边x. 答：Math.cos(45*Math.PI/180)*20; 3.已知A是55°，对边为20，求其邻边x. 答：20/Math.tan(55*(Math.PI/180)); 4.已知角B为60°，AC长为8，AB长为5，求角C的正弦. 答：5/(8/Math.sin(60*(Math.PI/180))); 5.已知C大小为120°,B大小为30°,AC=6,求AB长x. 答：(6/Math.sin(30*(Math.PI/180)))*Math.sin((180-120)*(Math.PI/180)); 6.△ABC中，A,B,C所对的边为a,b,c。角B=30°，AB=9，AC=3√3，求角C的大小. 答：Math.asin(9/((3*Math.sqrt(3))/Math.sin(30*(Math.PI/180))))/(Math.PI/180); Tips :因为sin(C) = sin(180° - C)，所以有两个解，60°和120°。 当然也不是一定就有两个解，如果B+C&gt;180°那肯定是不行的，就像这种题： 学生时代考试就经常忘记有多个解，有木有！！！ 7.已知AB=5,BC=8,角B=60°，求x. 答：Math.sqrt(Math.pow(5,2)+Math.pow(8,2)-(2*5*8*Math.cos(60*(Math.PI/180)))); 8.已知三边长为3,7,8，求边长为7的AC边所对的角B大小. 答：Math.acos((Math.pow(3,2)+Math.pow(8,2)-Math.pow(7,2))/(2*3*8))/(Math.PI/180); 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你切身体验实例被new出来的过程]]></title>
    <url>%2F2017%2F01%2F18%2F2017-01-18-new-object%2F</url>
    <content type="text"><![CDATA[其实费尽心力探寻底层实现就是为了用来装逼 😝 闲话网上有很多帖子、文章介绍new操作符运行步骤的文章，但我感觉读者看完之后还是会很模糊，知其然，不知其所以然。 好，轮到我装逼了！ 首先，读这篇文章，你得对原型链和构造函数有个基本的认识，否则收益不会很大，反而会更懵逼。 正文我们先创建一个简单的构造函数： 1234567function Rocker(name)&#123; this.name = name;&#125;;Rocker.prototype.getName = function()&#123; return this.name;&#125; 这是最简单不过的构造函数了，正常情况下，我们要生成他的一个实例，只需要： var someOne = new Rocker(&#39;Max&#39;) 这样就实例化了一个对象，但是，实例化的过程是怎样的呢？ 可能很多朋友在网上也看了很多文章，new的过程不就是三步吗？ 开辟一个块内存，创建一个空对象 执行构造函数，对这个空对象进行构造 给这个空对象添加proto属性 没错，是这三步，但是你真的理解了吗？至少我第一次看挺懵逼的。 好吧，最直观的方法就是，把创建一个对象的过程用代码体现出来，这样才能装逼嘛… 体验让我们创建一个函数，来实现上面new操作符的功能： 123456789101112131415161718var createObject = function()&#123; var obj = new Object(), //(1) Constructor = [].shift.call(arguments); //(2) obj.__proto__ = Constructor.prototype; //(3) var ret = Constructor.apply(obj, arguments); //(4) return typeof ret === 'object' ? ret : obj; //(5)&#125;;var shock = createObject(Rocker, 'Shock');console.log(shock.name); //Shockconsole.log(shock.getName()); //Shockconsole.log(Object.getPrototypeOf(shock) === Rocker.prototype); //true 就是上面这几句代码，向你展现了一个实例被new出来的过程。 分析一下我们来简单分析一下吧，其实很清晰明了了。 在(1)处，我们创建了一个空对象（准确的说是克隆了Object.prototype对象） 接下来(2)取到构造函数，赋值给Constructor变量，也就是说Rocker构造函数变成Constructor的一个引用了 接着(3)把Constructor.prototype（也就是Rocker.prototype）赋值给(1)刚刚创建的obj的原型链，或者这么说，把obj的原型链指向Constructor的原型 (4)我们用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入（在第2步时已经用shift把第一个参数去除了），此时的ret已经是一个合格的实例了！ 保险起见，我们(5)返回时判断ret是否是对象，如果不是就返回一个空对象（因为很多人真的不会按照规矩传参！！！） 这时候我们再外部调用这个函数试试，实时证明确实能达到new的效果。 再用getPrototypeOf方法测试一下，shock的原型链真的指向Rocker的原型！ 这就是实例被new出来的过程，你明了吗？ 其实上面代码有很多小技巧，可以细细咀嚼。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几分钟帮你理解对象的基本特性之一：多态]]></title>
    <url>%2F2017%2F01%2F16%2F2017-01-16-polymorphism%2F</url>
    <content type="text"><![CDATA[多态不是简单两句话可以讲清楚，但至少能让你明白它是什么。 简单解释多态拆分一下多态的英文：Polymorphism 就是 poly(复数) + morph(形态) + ism，也就是多种形态。 在JavaScript中，我们可以这样去理解多态：同一操作作用在不同的对象上，可以产生不同的解释和不同的执行结果。 更简单一些说：给不同对象发送同一消息，可能会得到不同的反馈。 举个🌰栗子Shock是一位吉他手，Alex是一名主唱，当他们听到鼓点响起时，Shock会开始弹吉他，Alex会开始演唱。 同样一个鼓点，但Shock和Alex做的事是不同的。 代码实践下面几行代码简单的把上面的例子实现，说明了对象的多态特性： 123456789101112131415var playDrum = function(bandsman)&#123; if(bandsman instanceof Guitarist)&#123; console.log('哆啦咪嗦啦'); &#125;else if(bandsman instanceof Singer)&#123; console.log('We will rock u!') &#125;&#125;var Guitarist = function()&#123;&#125;;var Singer = function()&#123;&#125;;playDrum(new Guitarist());//哆啦咪嗦啦playDrum(new Singer());//We will rock u! 上面代码虽然实现了”多态”的特性，但这种”多态”是不让人满意的，如果贝斯手来了，我们还得去修改playDrum的代码，要知道，修改代码风险太大了，BUG往往就是那个时候出现的。 其实多态背后的核心思想是：将“做什么”和“谁去做以及怎样做”相分离，也就是将“不变的事物”和“可能改变的事物”相分离。 在上面这个例子中，鼓手打鼓是不会改变的，改变的是不同乐手的演奏方式，我们可以将不变的分离出来，把可变的封装起来。 这样我们的代码就是可扩展的，也符合开放-封闭原则，这显得优雅和安全的多。 升级版🌰栗子12345678910111213141516171819var playDrun(bandsman)&#123; bandsman.play();&#125;var Guitarist = function()&#123;&#125;;Guitarist.prototype.play = function()&#123; console.log('哆啦咪嗦啦');&#125;var Singer = function()&#123;&#125;;Singer.prototype.play = function()&#123; console.log('We will rock u!')&#125;playDrum(new Guitarist());//哆啦咪嗦啦playDrum(new Singer());//We will rock u! 现在，当吉他手和主唱听到鼓点，他们还是会做出不同的反应。 这时如果贝斯手来了，那很简单，加上贝斯手就行了： 12345678var BassPlayer = function()&#123;&#125;;BassPlayer.prototype.play = function()&#123; console.log('嗡嗡嗡');//真的不是在黑贝斯...&#125;playDrum(new BassPlayer());//嗡嗡嗡 以上只是最直观的多态理解方式，还有利用继承得到多态效果、如何利用多态特性进行面向对象编程、多态与设计模式等等。 希望这篇文章能帮到你更好的理解JavaScript中的多态特性。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Object</tag>
        <tag>Polymorphism</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』如果让海明威写JavaScript]]></title>
    <url>%2F2017%2F01%2F05%2F2017-01-05-Hemingway-javascript%2F</url>
    <content type="text"><![CDATA[原文链接：http://byfat.xxx/if-hemingway-wrote-javascript 在写第一行代码很久以前，我就酷爱文学。现在，我写JavaScript，不计其数。我正在写一本关于JavaScript的书。 JavaScript凭啥能吸引那么多文艺青年？说到它有限的语法所具备的表达潜能，我倒是有几点不成熟的想法，不过那是另外一个话题了。哎，如果那些大作家都喜欢上JavaScript，会咋样？你说他们会用JavaScript写出点什么东西来？作为海明威的十足拥趸，我的第一反应也是这老爷子不可能喜欢编程序（包括程序员）。话虽如此，我还是愿意相信在对它的各种非议中，其实潜藏着足以打动人心的一点：它是一门很文艺的语言，你说呢？它表面上简单粗陋、平淡无奇，而实质上却引人入胜、内涵十足。 代码审查之母 前些天，我做了一个梦。梦见我让海明威还有其他四位作家给我写点JavaScript，特别是得写一个能返回指定长度斐波纳契数列的函数。我发现这些作家解决问题的方法各有千秋，很有意思。不过确实都写得不错，至少都实现了既定的功能（连安德烈·布勒东都写出来了）。下面就是他们交给我的作业。 欧内斯特·海明威（美国作家）123456789101112131415function fibonacci(size) &#123; var first = 0, second = 1, next, count = 2, result = [first, second]; if(size &lt; 2) return "the request was made but it was not good" while(count++ &lt; size) &#123; next = first + second; first = second; second = next; result.push(next); &#125; return result;&#125; 毫不奇怪。海明威的代码非常凝练，没有浪费一个词一个变量。代码没什么出奇之处，甚至显得有点迂腐，可这正是海明威作品的长处。没有烦琐的逻辑，也没有花里胡哨的变量名。就那么简单直白地把活儿干了，干完完事儿。 海明威没心情跟傻瓜逗闷子，如果你想要的是一个长度小于2的数列，他根本不睬你：“我累啦，你的问题很白痴。” 威廉·莎士比亚（英国诗人、作家）12345678910111213141516171819202122232425262728293031function theSeriesOfFIBONACCI(theSize) &#123; //a CALCKULATION in two acts. //employ'ng the humourous logick of JAVA-SCRIPTE //Dramatis Personae var theResult; //an ARRAY to contain THE NUMBERS var theCounter; //a NUMBER, serv'nt to the FOR LOOP //ACT I: in which a ZERO is added for INITIATION //[ENTER: theResult] //Upon the noble list bestow a zero var theResult = [0]; //ACT II: a LOOP in which the final TWO NUMBERS are QUEREED and SUMM'D //[ENTER: theCounter] //Commence at one and venture o'er the numbers for (theCounter = 1; theCounter &lt; theSize; theCounter++) &#123; //By divination set adjoining members theResult[theCounter] = (theResult[theCounter-1]||1) + theResult[Math.max(0, theCounter-2)]; &#125; //'Tis done, and here's the answer. return theResult; //[Exuent]&#125; 这位文豪啰嗦了点，可也是独树一帜了。注意他的注释（不算场名和台本），典型的英文抑扬格五音步格律——共十对音节，每音步（两个音节）的重音都落在第二个音节上。在他的戏剧中，莎士比亚经常会脱离严格的抑扬格五音步格律以示强调，比如增加一个音节，或者采用交替重音。在这个编程作业中，他好像也运用了同样的技巧。码如其文。 安德烈·布勒东（Andre Breton，法国诗人和评论家，超现实主义创始人之一）1234567891011function Colette(umbrella) &#123; var staircase = 0, galleons = 0, brigantines = 1, armada = [galleons, brigantines], bassoon; Array.prototype.embrace = [].push; while(2 + staircase++ &lt; umbrella) &#123; bassoon = galleons + brigantines; armada.embrace(brigantines = (galleons = brigantines, bassoon)); &#125; return armada;&#125; 作为超现实主义运动的倡导者，布勒东主张梦想比现实更有趣，应该作为创作的出发点。他的变量命名颇具超现实主义色彩。尽管并非无可挑剔，但他的作品的确几近完美，真挚又美好。在他有意识的表达中，蕴含着一幅无意识的梦幻图景。可以把这个作业看成华美诗篇Facteur Cheval的再创作。 布勒东在这个斐波纳契函数中总是喜欢使用老相好的名字，他把结果想象成了一个史前舰队。他的方案逻辑优雅，巧妙地采用了逗号运算符在galleons、brigantines和bassoons之间同时迁移元素。向安德烈致敬！ 罗贝托·波拉尼奥（Roberto Bolano，智利诗人和小说家）1234567891011121314151617181920212223242526function LeonardoPisanoBigollo(l) &#123; if(l &lt; 0) &#123; return "I'd prefer not to respond. (Although several replies occur to me)" &#125; /**/ //Everything is getting complicated. for (var i=2,r=[0,1].slice(0,l);i&lt;l;r.push(r[i-1]+r[i-2]),i++) /**/ //Here are some other mathematicians. Mostly it's just nonsense. rationalTheorists = ["Archimedes of Syracuse", "Pierre de Fermat (such margins, boys!)", "Srinivasa Ramanujan", "Rene Descartes", "Leonhard Euler", "Carl Gauss", "Johann Bernoulli", "Jacob Bernoulli", "Aryabhata", "Brahmagupta", "Bhaskara II", "Nilakantha Somayaji", "Omar Khayyám", "Muhammad ibn Mūsā al-Khwārizmī", "Bernhard Riemann", "Gottfried Leibniz", "Andrey Kolmogorov", "Euclid of Alexandria", "Jules Henri Poincaré", "Srinivasa Ramanujan", "Alexander Grothendieck (who could forget?)", "David Hilbert", "Alan Turing", "von Neumann", "Kurt Gödel", "Joseph-Louis Lagrange", "Georg Cantor", "William Rowan Hamilton", "Carl Jacobi", "Évariste Galois", "Nikolay Lobachevsky", "Rene Descartes", "Joseph Fourier", "Pierre-Simon Laplace", "Alonzo Church", "Nikolay Bogolyubov"] /**/ //I didn't understand any of this, but here it is anyway. return r /**/ //Nothing happens here and if it does I'd rather not talk about it.&#125; 如果这辈子没看过波拉尼奥的著作，那你的生命是不完整的。波拉尼奥的作品忽而精于事故，忽而憨态可掬，让人叹为观止。他的叙事风格以毫无悬念的坦诚见长。人类的弱点始终存在，但温暖幽默地传达出每一个弱点，却无不令人沉醉、催人振奋。 一如既往，他的编程作业也流露出了一种不安、局促和无知。他给出的解答尽管颇显才情，可总让人觉得有几分累赘。偏执依旧，跑题依旧，他好像更愿意向我们展示似乎很有意思，但其实毫无用处的天才数学家名录。 以下几方面也是波拉尼奥的特点，比如长短段并列、忘记加分号（对应着他小说中缺失的引号），以及隐含地使用全局变量——暗示每个变量注定会在后续章节中再次现身。 查尔斯·狄更斯1234567891011function mrFibbowicksNumbers(enormity) &#123; var assortment = [0,1,1], tally = 3, artfulRatio = 1.61803; while(tally++ &lt; enormity) &#123; //here is an exceedingly clever device assortment.push(Math.round(assortment[tally-2] * artfulRatio)); &#125; //should there be an overabundance of elements, a remedy need be applied return assortment.slice(0, enormity);&#125; 我不是狄更斯的粉丝。我基本同意亨利·詹姆斯（美国著名小说家和批评家）的恶评： “要是让我们冒险评价一下他的文学成就，可以称他为最肤浅的小说家。没错，这么说等于把它归入了他所处的文学领域的低等行列，但我们愿意承认这一点。把狄更斯先生归入最伟大的小说家之列，我们是过意不去的。因为他除了人物角色，并没有创造其他任何东西。他没有对我们理解人物角色多给任何资料。” ——亨利·詹姆斯谈查尔斯·狄更斯，评《我们共同的朋友》，1865年12月21日 他的肤浅从他的斐波纳契作业中可见一斑。没错，变量名还算中规中矩，但却是他无法把握实质性内容和内心理解不到位的表现。他没有从实质上领会斐波纳契数列的含义，倒是一心想通过乘法解决问题。哎。 最终点评不管是老道（Crockford）的极力维护，还是干巴巴的计算机科学课，条条框框始终是JavaScript的敌人。有些开发者喜欢手册和样板，结果就是Java。JavaScript的趣味性源自它天性就不刻板，以及由此生发的无限可能。自然语言也具有相似的特点。最好的作者和最优秀的JavaScript开发者一定会对这门语言神魂颠倒，没有一天不在探索和实践它，从而塑造自己的风格、自己的习惯，还有自己的表达方式。 就这些，希望你喜欢。恐怕大都是无稽之谈。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oh-my-zsh中git常用命令]]></title>
    <url>%2F2017%2F01%2F04%2F2017-01-04-zsh-git%2F</url>
    <content type="text"><![CDATA[自己常用的几个命令 希望能帮到你 Alias Command ga git add gcmsg git commit -m gp git push gl git pull gst git status gd git diff gm git merge gb git branch gco git checkout 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>oh-my-zsh</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台湾和大陆不一样的术语称呼]]></title>
    <url>%2F2017%2F01%2F02%2F2017-01-02-tw-spaeak%2F</url>
    <content type="text"><![CDATA[买了本湾湾翻译的书来看，真想说台湾话真是狗屎，但真正从历史上来说，简体中文才是狗屎 整理了一下台湾和大陆一些不一样的术语，读起来简直痛苦 台湾 大陆 物件 对象 函式 函数 变数 变量 阵列 数组 正规 正则 特性 属性 程式 程序 字串 字符 注解 注释串 宣告 声明 引数 参数 型别 类型 迴圈 循环 实体 实例 范畴 作用域 呼叫 调用 自由 自动 建置 构建 资料 数据 剖析 解析 实作 操作 参考 指针 标记 标签（元素） 伺服器 服务器 建构器 构造器 程式码 代码 运算式 表达式 指令稿 脚本 字面值 字面量 识别字 关键字 运算子 运算符 物件导向 面向对象 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 我的书单]]></title>
    <url>%2F2017%2F01%2F01%2F2017-01-01-book-list%2F</url>
    <content type="text"><![CDATA[2017来了，整理下过去一年的书单 JavaScript语言精粹 – Douglas Crockford JavaScript这门语言是伟大的，但同样也有许多让人诟病的地方，这本书告诉你哪些是JavaScript的精粹，我们应该去使用；哪些是毒瘤，尽量避开它们。从而有效保证我们的代码质量。 JavaScript高级程序设计 – Nicholas C.Zakas这本书应该不用过多介绍了，之前断断续续的看过里面的一些章节，今年花了一个月的时间，把这本书从头到尾读完了。 相比犀牛书，这本书读起来不会那么枯燥，不仅仅是工具书，里面也涉及了很多实际开发会遇到的问题，圣经级别的。 JavaScript忍者秘籍 – John Resig / Bear Bibeault这本书将告诉你，为什么JavaScript会如此充满魅力。 本书围绕函数来展开，让你更清楚的理解JavaScript为什么是一门函数式语言。 由浅入深地覆盖了测试和测试工具、函数、闭包、对象、正则表达式、定时器、运行时代码求值、with语句、跨浏览器问题、元素的特性和属性、事件处理、DOM以及CSS选择器等众多核心话题。 并且里面的例子都是实际开发中可以直接使用并借鉴的，但本书并不适合初学者。 Speaking JavaScript – Axel Rauschmayer目前还没有简体版，只能买繁体版的，价钱真是让我心痛了一把。 这本书讲了很多JavaScript这门语言的底层实现，能让你更好的去认识这门语言，而不仅仅是停留在会使用。 比如它的强类型转换、分号的自动补全等等是怎么实现的，当你下次写代码时就知道，原来这些代码运行时，内部是经历了这些阶段。 算是我看过的JavaScript最底层的一本书了，认识了这门语言的很多本质。 PHP和MySQL Web开发 – Luke Welling / Laura Thomson 因为大学就有学后端的一些东西，不想把这些知识都丢了，所以年初花时间把这本书又看了一遍。 发现忘记了很多知识，果然还是要温故知新啊。 这本书不能让你成为PHP和MySQL高手，但是入门完全够了，而且也不枯燥，书中有很多例子给你实践。 牧羊少年奇幻之旅 – Paulo Coelho这本书算是这个浮躁世界的一股清泉吧。 也是看到网友推荐，说是在你迷茫的时候读读，会让你找到方向。 虽然没有那么神奇，但也确实让我意识到一件事：很多东西是没意义的，是在你去做、去想的过程中，它才有了意义。 白夜行 – ひがしの けいご看到最后的结局，我控制不住的流泪了。 人之初，性本善。可恨之人必有可怜之处，我一直都相信这句话。 孩童时期一些经历可以决定一个人的一生。其实现在的我们都是环境的产物，不同的环境塑造了不同的人。 人类简史 – 尤瓦尔·赫拉利作者用上帝视角，讲述了我们（智人）从认知革命一直到科学革命的变化，以及这个世界是怎样运转的，人类文化、宗教、法律、国家、信贷……这是一部宏大的史诗作品，让人类重新审视自身。 三体 – 刘慈欣这是我第一本科幻小说，之前一直觉得科幻小说就是作者奇思妙想，描写一个不可思议的世界，所以一直对这类小说有抵触心理。 但是三体让我感受到了真实，未来真的会是这样吗？那人类又算什么？我们将不再担任上帝的职位了吗？ 这本书只能用震撼来形容，适合所有年龄段，其实每个人类都应该承担面壁者的责任。 结语读书能让你站在巨人的肩膀上，一本书可能是别人几十年经验的结晶，它能让你学到更多的知识，去经历不同的人生。 毕竟，现实生活这么糟糕，生活在一个虚拟的世界里不是更好吗？ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『翻译』Socket.IO聊天室程序（官方示例）]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26-socket-io%2F</url>
    <content type="text"><![CDATA[官方最新版的示例翻译 阅读原文 开始创建：聊天室程序(Get Started: Chat application)在这个教程中，我们将会创建一个基本的聊天室程序。它几乎不需要你懂得多少Node.js和Socket.IO的知识，所以，这个教程适用于各个技术水平的开发人员。 介绍(Introduction)使用LAMP（PHP）这种传统的技术栈去编写一个流行的聊天室程序是很困难的。它包括了服务器的轮询，跟踪时间戳，用它们去做这些会耗费你很多时间。 一直以来，sockets都是即时聊天系统的架构解决方案，它提供一个双向的通讯通道在客户端和服务器之间。 这意味着服务器可以推送消息到客户端。无论你何时发送聊天信息，我们都希望服务器获取到它，并把它推送到其他连接服务器的客户端上。 Web 框架(The web framework)首先，我们要建立一个简单的HTML页面，负责提交表单和展示消息列表。我们将使用Node.js的web框架express去实现。请确保你安装了Node.js。 我们先创建一个package.json来描述我们的项目。我建议你创建一个空文件夹（我把它叫做chat-example）。 123456&#123; "name": "socket-chat-example", "version": "0.0.1", "description": "my first socket.io app", "dependencies": &#123;&#125;&#125; 现在，按顺序把我们所需要的依赖填充到dependencies，我们使用npm install --save： npm install –save express@4.10.2 现在，express已经安装完成，我们创建一个index.js文件，开始搭建我们的程序。 12345678910var app = require('express')();var http = require('http').Server(app);app.get('/', function(req, res)&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);http.listen(3000, function()&#123; console.log('listening on *:3000');&#125;); 上面这段代码的意思如下： Express把app初始化为函数处理器(function handler)，它提供了一个HTTP服务。 我们定义一个路由处理器/，当我们进入网站首页时，它会执行。 我们创建一个http服务去监听3000端口。 如果你运行node index.js，你会看到如下所示： 接下来在浏览器输入http://localhost:3000，你会看到如下所示： 创建HTML(Serving HTML)到目前为止，index.js只是用res.send返回一个HTML字符串。如果我们把整个程序的HTML代码都放在这，那会使我们头晕眼花，我们再创建一个index.html并启动它。 我们改写路由处理器，用sendFile代替send： 123app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;); 然后在index.html中写入以下内容： 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="messages"&gt;&lt;/ul&gt; &lt;form action=""&gt; &lt;input id="m" autocomplete="off" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如果你重启服务(按Control+C再运行node index.js)，刷新页面，你会看到如下界面： 集成Socket.IO(Integrating Socket.IO)Socket.IO由两部分组成： 一个集成（或安装）了Node.js HTTP服务的服务器：socket.io 一个加载在浏览器上的客户端库：socket.io-client 在开发时，socket.io为我们自动的服务客户端，就像我们看到的那样，所以现在我们只需要安装一个模块： npm install –save socket.io 包管理工具会安装这个模块，并将依赖项添加到package.json。现在让我们在index.js中写入以下代码： 123456789101112131415var app = require('express')();var http = require('http').Server(app);var io = require('socket.io')(http);app.get('/', function(req, res)&#123; res.sendfile('index.html');&#125;);io.on('connection', function(socket)&#123; console.log('a user connected');&#125;);http.listen(3000, function()&#123; console.log('listening on *:3000');&#125;); 注意，我通过http(HTTP服务器)对象初始化了一个socket.io实例。然后，我监听sockets的connection事件，然后我使用console.log打印出它。 现在我们再index.html中添加如下代码，在&lt;/body&gt;标签上方： 1234&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io();&lt;/script&gt; 我们需要加载socket.io-client，它暴露了一个全局函数io，运行它，接着去连接服务器。 注意，当我调用io()时，不指定任何URL，因为它默认会尝试连接到这个页面的主机服务器。 如果你现在重启服务并刷新网页，你将看到终端打印出”a user connected”： 每个socket同样会触发一个特殊的disconnect事件： 123456io.on('connection', function(socket)&#123; console.log('a user connected'); socket.on('disconnect', function()&#123; console.log('user disconnected'); &#125;);&#125;); 接下来，你重启服务，刷新网页并关闭它，就可以看到事件的执行： 发射事件(Emitting events)Socket.IO最主要的思想就是你可以发送和接收任何你想的事件、任何你想要的数据。任何对象都可以使用JSON进行编码，包括二进制数据同样支持。 让我们来实现，当用户发送一条信息时，服务器接收一个chat message事件。index.html的脚本部分修改成如下所示： 12345678910&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script src="http://code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io(); $('form').submit(function()&#123; socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;);&lt;/script&gt; 然后在index.js中，我们打印chat message事件： 12345io.on('connection', function(socket)&#123; socket.on('chat message', function(msg)&#123; console.log('message: ' + msg); &#125;);&#125;); 结果应该如下视频所示： 广播(Broadcasting)下一个目标是，将发射的事件通过服务器广播给其他用户。 为了发送一个事件给每个用户，Socket.IO给了我们一个io.emit接口： 1io.emit('some event', &#123; for: 'everyone' &#125;); 如果你想发送一则消息给所有人，除了当前socket的拥有者，我们可以使用broadcast标记: 123io.on('connection', function(socket)&#123; socket.broadcast.emit('hi');&#125;); 这这个实例中，为了简单起见，我们把消息发送给每一个人，包括消息的发出者： 12345io.on('connection', function(socket)&#123; socket.on('chat message', function(msg)&#123; io.emit('chat message', msg); &#125;);&#125;); 当客户端捕获到chat message事件，我们将消息插入到页面中。以下为客户端所有的JavaScript代码： 1234567891011&lt;script&gt; var socket = io(); $('form').submit(function()&#123; socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;); socket.on('chat message', function(msg)&#123; $('#messages').append($('&lt;li&gt;').text(msg)); &#125;);&lt;/script&gt; 完成我们的聊天室程序，只需要20行代码左右！它看起来像这样： 课后作业(Homework)这里有一些点子来改善这个程序： 当有人加入聊天室或退出聊天室时，广播一则消息给所有已连接的用户 支持昵称功能 不要向自己发送消息，而是在用户回车后立即添加消息到页面上 增加”某某正在输入”的功能 展示哪些人在线上 增加私人消息传输 展示你的改进结果！ 获取示例(Getting this example)你可以在GitHub上找到它。 点击获取示例 如果你电脑有装git，直接在项目目录下输入以下命令： $ git clone https://github.com/guille/chat-example.git 完 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>Socket.IO</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用内联函数进行递归]]></title>
    <url>%2F2016%2F12%2F19%2F2016-12-19-inline-function%2F</url>
    <content type="text"><![CDATA[我曾经以为匿名函数就是匿名函数，事实上，匿名函数就是匿名函数。 在JavaScript中实现递归有很多种方法，常见的有使用函数名调用自身、使用arguments.callee。 现在有这么一个例子，判断一个字符串是不是回文，返回’true’或’false’。 我们把递归函数赋值给一个对象的属性： 1234567var JudgeTool = &#123; isPalindrome : function (text)&#123; if (text.length &lt;= 1) return true; if (text.charAt(0) != text.charAt(text.length - 1)) return false; return Judge.isPalindrome(text.subString(1,text.length - 2)); &#125;&#125; 我们可以用一个回文字符串测试一下： 1JudgeTool.isPalindrome("htmlmth"); //返回true 功能是实现了，但是，如果另一个对象也想拥有一个同样功能的方法，我们或许可以这样做： 123var AnotherTool = &#123; isPalindrome:JudgeTool.isPalindrome&#125; 没有问题，我们依然可以用AnotherTool.isPalindrome方法去判断字符串是否是回文，但是，如果我在AnotherTool对象后面加一句： 1JudgeTool = &#123;&#125;; 大家可以想到，肯定会出错，因为在递归函数内部调用的是Judge.isPalindrome()，现在Judge对象被重置，那肯定取不到这个对象的属性了。 那我们改写一下函数内部的递归调用： 1234567var JudgeTool = &#123; isPalindrome : function (text)&#123; if (text.length &lt;= 1) return true; if (text.charAt(0) != text.charAt(text.length - 1)) return false; return this.isPalindrome(text.subString(1,text.length - 2)); &#125;&#125; 我们只改写了一处，把Judge.isPalindrome改成了this.isPalindrome，现在再清空Judge对象，我们还是能够调用AnotherTool.isPalindrome，因为this是指向当前调用此方法的对象。 但问题又来了，我们的方法名必须为：isPalindrome，如果我不想叫这个方法名，又或者函数的其中一个引入不是对象的属性怎么办？这时候就要引入内联函数的概念了。 看下例子，我们可以这样改写Judge对象： 1234567var JudgeTool = &#123; isPalindrome : function same(text)&#123; if (text.length &lt;= 1) return true; if (text.charAt(0) != text.charAt(text.length - 1)) return false; return same(text.subString(1,text.length - 2)); &#125;&#125; 注意，我们只给匿名函数加了一个名字，并且在内部用这个名字去调用它，这样，不管外面的方法名怎么变，都不会影响到内部的函数运行。 这个技巧在很多地方都有用到，如果你有看jQuery源码的话。 而且有趣的是，在函数内部，JudgeTool.isPalindrome == same 为true 。 尽管我们可以给内联函数进行命名，但这个名称只在函数内部可见，你可以把内联函数的名称想象成函数内的一个变量，它的作用域仅限于函数的内部。 我们看这样一个例子就明白了： 12345var foo = function bar()&#123; typeof bar;//返回function&#125;typeof bar;//返回undefined 这个技巧在递归中常常会用到，如果你留意的话。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信仰有多重要？]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-faith%2F</url>
    <content type="text"><![CDATA[生命对每个人都是公平的，因为洪流的终点都是死亡。 朋友，能否借用您漫长人生中短短的几分钟时间，咱们聊聊信仰有多重要？ 我们不去给信仰定义，我只想请你坐下来思考一会，你所有烦恼的源头来自于何处？ 我们来假设一下，你之所以烦恼是因为你觉得钱不够花。 我们不讨论怎么去赚更多的钱，而是假设你的钱可以满足你的一切欲望，好了，烦恼解决了。 但现实并不是这样的，你在获得这些钱的过程中，会经历很多事情，会去思考并去做很多肮脏和见不得人的事情。 最终，这些肮脏和见不得人的事将会陪伴你终生，与你长眠。 当然，上面只是做了一个假设，但是我们可以想象到，这是一件多么恐怖的事，你的心里一直有一块黑暗的角落，不敢向任何人提及，因为你知道，这是肮脏的交易，不被这个物质世界所接受和允许。 于是你一辈子都把那些只有你自己才知道的小秘密埋在心里，不敢也不能向他人提及，比如我告诉你，我和前女友的孩子已经三岁了，我却没有见过他长什么样，甚至连是男是女也不确定，我是人渣吗？ 很多人就这样带着他们的小秘密离开了人世，一直到生命的尽头，为了生活，做了那么多肮脏的事情，都不知道是为了什么，为了什么而活了这一辈子。 朋友，你真的有停下你的脚步，想过这个问题吗？你为了什么而活？ 如果此刻，出现这样一个人，我把我所有的财产给他，而他，什么都不需要做，只需要静静的凝听我做过的所有肮脏的事，我所有的小秘密统统告诉他，但是有一点，他得保密，这些事情全世界只有我和他知道，不允许有第三个人。因为肮脏的事是不允许出现在阳光下的。 如果真的有这样一个人，我愿意。 但是我真的能去街上随便抓一个不认识的人，告诉他我要把我所有的财产赠与他，只求他能保守秘密？别人只会打110。 那怎么办？找身边的人倾述？但是，你确定你不会有一些肮脏的小秘密，肮脏到这个世界不能有第二个人知道？ 你的灵魂一角无时无刻都有一块被黑暗笼罩，那片黑暗将会跟随你，到老，到死。 如果看到这里，你觉得自己不是一个肮脏的人，那请出门右拐，那里阳光明媚。 那我问你，你为什么而活，你能回答我吗？让我来告诉你吧。 我知道你在想些什么，为了家人？为了生活？为了爱情？为了金钱？ 不管你为了什么而活，在活的这个过程中，你总会想、会做一些事情，暂且叫见不得人的事吧。 这些事情会一直笼罩你的灵魂，因为你不敢把他们放出去，放出去让别人知道了可就要让我的生活一团糟了。 最好是把这些带进坟墓，这样才安全一些，所以，一直到死的那一刻你都不知道自己为了什么而活。 如果有一个人可以包容你想过、做过的任何肮脏的事情，而且他还绝对保密，不会告诉这个世界一丝一毫。 如果你不知道这是什么感觉，那你肯定没有讲过真话， 因为这就是讲真话的感觉。 你把这肮脏的一切都暴露给他，这样就把肮脏暴露于阳光之下了，同时还不必担心被这个世界的其他人发现。 但是你不能直接和他说这一切，得通过一个中间人转达，问题是你并不知道这个中间人会不会把你的秘密告诉第四个人。 所以，朋友，得看你的罪有多大了。 小罪，我们可以赎；大罪，可就赎也赎不完了，因为到最后，你最最肮脏的秘密，可是连他也不能容忍的，你不能说。 所以，趁着我们还未酿成大罪之前，你可以把你内心所有肮脏不可告人的秘密告诉他，他可以包容你。 这是多么幸福的一件事啊！你能把你心里所有的阴暗驱逐，你是一个干净的人了！ 但是活着，又会有肮脏的事找上你。你必须不断赎罪，继续活着。 所以，你知道活着的意义了吗？ 你知道信仰有多重要了吗？ 不知道没关系，因为你这辈子也不会知道说真话有多爽！ 睡一觉，醒来继续活。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Mind</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>信仰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶魔的呢喃]]></title>
    <url>%2F2016%2F12%2F12%2F2016-12-12-evil%2F</url>
    <content type="text"><![CDATA[惰性就是你内心的恶魔，它在你耳边呢喃，放弃吧，你会过的很快乐。 恶魔大概两年前，就有了想搭建个人博客的想法，当时想用HEXO+GitHub来做，可以想到，实践中会碰到很多问题，我前前后后花了一周时间，最后还是没有搭建出来。一直到两年后的今天，我才又着手去搭建博客。 我知道，不只是我，很多朋友都会有这种体验，学习一门新知识，然后碰到问题，去寻找答案，发现解决这个问题还要涉及到其他的知识。 这个时候你心里的那个恶魔就会出现，它会对你说：休息一会吧，你已经很努力了，就算学不会这些，你也一样可以过得很好。 其实想想，成功和失败，有时候就是因为自己一时的懒惰，在西方人看来，这就是被恶魔所打败。 讲个故事前段时间看了电影《云图》，讲的其实就是汤姆·汉克斯和内心恶魔斗争的故事，最后一个高潮，在攀登山峰时，先知女掉了下去，汉克斯手里握着绳子，这时，恶魔出现了。 恶魔在他耳边说，放手吧，让她掉下去吧，不然你也会用尽力气，两个人都会摔死。 故事的结尾是汉克斯和先知女结婚了，生了很多宝宝，如果当时他向恶魔屈服，我相信他的后半生会在忏悔和折磨中度过。 回到现实没有人愿意去改变现状，改变意味着思考，思考就会发现问题，有问题就需要去解决，你会很烦恼。 少年，这也就是别人为什么比你成功的原因，你真的很勤奋努力吗？只有你自己知道。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Mind</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue数据绑定隐藏的神坑....]]></title>
    <url>%2F2016%2F12%2F01%2F2016-12-01-vue-problem%2F</url>
    <content type="text"><![CDATA[出现问题是好的，那说明你在行动。 今天被Vue的一个坑给折磨了一天，终于发现是什么问题，我们先来模拟一个场景：代码如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model='sendJson.name'&gt; &lt;button @click='showName'&gt;打印输入框的值&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript" src='./vue.min.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el:'#app', data()&#123; return&#123; sendJson:&#123;&#125; &#125; &#125;, methods:&#123; showName()&#123; console.log(this.sendJson.name) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们进页面就点按钮，你猜会输出什么？ 是undefined，不算奇怪，你什么都没输入，当然是undefined了。 OK，接下来刷新页面，进去多一步操作，先点击一下input输入框，在点击按钮，只是多做这一步操作： 输出的是空白，在chrome中空白就代表空字符串，可以修改一下打印结果： console.log(this.sendJson.name === &quot;&quot;) 其实这看起来不是个大问题，但是在我的场景里问题就大了。 我要把输入框内的值作为一个对象的属性，问题就来了，看图： 这个坑牛逼不，我真是个奇葩。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用自记忆函数提高页面性能]]></title>
    <url>%2F2016%2F11%2F11%2F2016-11-11-memoization%2F</url>
    <content type="text"><![CDATA[当你真正想要提高页面性能，你会发现你的代码和屎没两样。 自记忆函数这个名字听起来有点奇怪，这只是人们给它取的一个名字罢了。 在JavaScript中，函数是第一型对象，所以它可以拥有自己的属性，我们就可以利用这一点来进行数据的缓存。 还是先看一个例子，isPrime函数用来判断参数是否是素数，和普通函数唯一的不同在于我们暗中创建了一个answers缓存： 1234567891011121314151617function isPrime(value) &#123; if (!isPrime.answers) isPrime.answers = &#123;&#125;; if (isPrime.answers[value] != null) &#123; return isPrime.answers[value]; &#125; var prime = value != 1; // 1永远都不会是素数 for (var i = 2; i &lt; value; i++) &#123; if (value % i == 0) &#123; prime = false; break; &#125; &#125; return isPrime.answers[value] = prime; &#125;isPrime(5)//true isPrime.answers[5]//true 我们首先判断isPrime函数是否有answers属性，没有就创建一个。 接下来我们检查answers是否存在参数值对应的结果，在该缓存里，我们用参数值作为属性的key，如果发现缓存结果，则直接返回它。 如果在缓存中没有找到结果，就计算该参数判断是不是素数。 最后返回判断结果，并赋值给answers属性的[value]。 下面的测试证明，确实可以从isPrime.answers中取到之前计算过的结果。 当有大量数据需要计算，并且数值很大的情况下，这种性能的优化可能会大到你无法想象。 在我们实际工作中可能很少去计算素数，那再举一个大家常见的例子，缓存DOM元素。 通过标签查询DOM元素是我们常常做的一件事，但频繁操作性能很糟糕，我们可以利用刚刚学会的缓存记忆创建一个缓存，保存已匹配到的元素集合： 123456function getElements(name)&#123; if (!getElements.cache) getElements.cache = &#123;&#125;; return getElements.cache[name] = getElements.cache[name]|| document.getElementsByTagName(name);&#125; 其实缓存代码非常简单，并不会给你的代码逻辑增加太多复杂性，但是，上面这几行简单的缓存代码，就产生了5倍的性能提升，如表： 所有测试都在chrome53下进行了100000次迭代的毫秒数 代码版本 平均时间 最小时间 最大时间 运行次数 非缓存版本 16.7 18 19 10 缓存版本 3.2 3 4 10 使用自记忆函数技巧，不仅在代码组织上有好处，而且储存对象无需污染作用域，就可以获得性能提升。 缓存记忆有两个主要优点： 最终用户享有绝对性能优势。 发生在幕后，完全无缝，最终用户和开发人员都无需任何特殊操作或为此做任何额外的初始化做工。 相比优点，也要权衡一下缺点： 为提高性能，任何类型的缓存都会牺牲掉内存。 纯粹主义认为，储存不应该和业务逻辑放在一起，函数或方法只做一件事，并把它做好。 很难进行算法性能的测试 至于，是否运用这种技巧在你项目中，那得看你的实际情况了。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由Vue引发的getter和setter思考]]></title>
    <url>%2F2016%2F10%2F25%2F2016-10-25-vue-getter-setter%2F</url>
    <content type="text"><![CDATA[接触新事物总会让人很难受，但也会让人成长。 公司的新项目决定使用Vue.js来做，当我打印出Vue实例下的data对象里的属性时，发现了一个有趣的事情： 它的每个属性都有两个相对应的get和set方法，我觉的这是多此一举的，于是去网上查了查Vue双向绑定的实现原理，才发现它和Angular.js双向绑定的实现原理完全不同，Angular是用的数据脏检测，当Model发生变化，会检测所有视图是否绑定了相关数据，再更改视图。而Vue使用的发布订阅模式，是点对点的绑定数据。 Vue的数据绑定只有两个步骤，compile=&gt;link。 我一直在想，vue是通过什么去监听用户对Model的修改，直到我发现Vue的data里，每个属性都有set和get属性，我才明白过来。 在平时，我们创建一个对象，并修改它的属性，是这样的： 12345var obj = &#123; val:99&#125;obj.val = 100;console.log(obj.val)//100 没有任何问题，但是如果要你去监测，当我修改了这个对象的属性时，要去做一些事，你会怎么做？ 这就要用到getter和setter了。 假设我现在要给一个码农对象添加一个name属性，而且每次更新name属性时，我要去完成一些事，我们可以这样做： 1234567891011121314151617181920var Coder = function() &#123; var that = this; return &#123; get name()&#123; if(that.name)&#123; return that.name &#125; return '你还没有取名' &#125;, set name(val)&#123; console.log('你把名字修成了'+val) that.name = val &#125; &#125; &#125; var isMe = new Coder() console.log(isMe.name) isMe.name = '余震' console.log(isMe.name) console.log(isMe) 输出： 你会发现这个对象和最上面的Vue中的data对象，打印出来的效果是一样的，都拥有get和set属性。 我们来一步步分析下上面的代码,很有趣。 我们先创建一个对象字面量： var Coder = function() {…} 再把this缓存一下： var that = this; 接下来是最重要的，我们return了一个对象回去： 12345&#123; get name()&#123;/*do something*/&#125;, set name(val)&#123;/*do something*/&#125;&#125; 顾名思义，get为取值，set为赋值，正常情况下，我们取值和赋值是用obj.prop的方式，但是这样做有一个问题，我如何知道对象的值改变了？所以就轮到set登场了。 你可以把get和set理解为function，当然，只是可以这么理解，这是完全不一样的两个东西。 接下来创建一个码农的实例，isMe；此时，isMe是没有name属性的，当我们调用isMe.name时，我们会进入到get name(){…}中，先判断isMe是否有name属性，答案是否定的，那麽就添加一个name属性，并给它赋值：”你还没有取名”；如果有name属性，那就返回name属性。 看到这里你一定知道get怎么使用了，对，你可以把get看成一个取值的函数，函数的返回值就是它拿到的值。 我感觉比较重要的是set属性，当我给实例赋值： isMe.name=”余震” 此时，会进入set name(val){…}；形参val就是我赋给name属性的值，在这个函数里，我就可以做很多事了，比如双向绑定！因为这个值的每次改变都必须经过set，其他方式是改变不了它的，相当于一个万能的监听器。 还有另一种方法可以实现这个功能。 ES5的对象原型有两个新的属性defineGetter和defineSetter，专门用来给对象绑定get和set。可以这样书写： 1234567891011121314151617var Coder = function() &#123; &#125; Coder.prototype.__defineGetter__('name', function() &#123; if (this.name) &#123; return this.name &#125;else&#123; return '你还没有取名' &#125; &#125;) Coder.prototype.__defineSetter__('name', function(val) &#123; this.name = val &#125;) var isMe = new Coder() console.log(isMe.name) isMe.name = '余震' console.log(isMe.name) console.log(isMe) 效果是一样的，建议使用下面这种方式，因为是在原型上书写，所以可以继承和重用，最近想写点小框架，才发现知识不够用，大家一起加油吧！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parseInt第二个参数详解]]></title>
    <url>%2F2016%2F09%2F03%2F2016-09-03-parseint%2F</url>
    <content type="text"><![CDATA[不常用不代表你不用去理解它，或许哪次装逼就用上了。 前阵子在stackOverflow上看到两个这样的问题： 为什么parseInt(8,3) == NaN，parseInt(16,3) == 1？ 为什么parseInt(‘dsff66’,16) == 13？ parseInt大家应该都很熟悉了，我们一般用他来把一个小数或字符串转换为整数，正常情况下我们都是这样做的: 123parseInt(11.2)//返回11parseInt("13")//返回Number类型的13 函数会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。 但是parseInt的第二个参数很多朋友就不太清楚了，因为本身就很少使用第二个参数，我们看看MDN上对第二个参数的解释： 一个2到36之间的整数值，用于指定转换中采用的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。总是指定该参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。 最后说到如果忽略的话，不同环境会有不同结果，大家不用担心，ES5已经规定了如果省略就代表用十进制解析。 第二个参数是2~36之间的整数值，这个值其实就是我们说的进制，比如，我们用二进制去解析第一个参数，那么就这么做： 1parseInt(101,2)//返回5 下面我们来分析一下上面的两个问题，相信大家对这第二个参数就能有个透彻的认识了。 为什么parseInt(8,3) == NaN，parseInt(16,3) == 1？ 先来看第一个parseInt(8,3) ，这里的意思就是用,三进制去解析8，我们知道二进制是遇2进1，三进制同样，遇3进1，比如我要用三进表示十进制中的5，那么就是12，也就是(2(3^0))+(1(3^1))=5； 所以在三进制中，出现的最大的数字也就是2，8这个数字不可能出现在三进制中，所以返回NaN。 parseInt(16,3)同样，出现最大的数字是2，那么6就是被自动忽略掉，所以parseInt是直接用三进制去解析1，得到的当然是1了。 为什么parseInt(‘dsff66’，16) == 13？ 我们知道，平时使用parseInt，它会忽略到除数字之外的字符，但是这里不一样，因为十进制最大的数字是9，但是到了十一进制往上，最大的数字是两位数了，这当然不行，所以从10开始往上，就用字母代替，a==10,b==11……z==35；所以你知道为什么parseInt的第二个参数要规定在2~36了吗？ 再看看上面这道问题，在16进制中，最大的数字是15，对应字母也就是f，超过f的字母也就超出了16进制的解析范围。 ‘dsff66’的第一个字符是d，也就是十进制中的13，第二个字符s，代表十进制中的28，这显然超出了16进制的解析范围，所以s和它之后的字符都会被parseInt自动忽略，所以我们得到13。 相信看到这里，你对parseInt的第二个参数已经完全了解了，如果你对进制之间的转换不太了解的话，可以多去网上学习学习进制之间的转换，就算平时用不着，还是可能拿来装X嘛。 另外补充一下，另一个函数parseFloat只接受一个参数，只能使用十进制去解析。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何伪造数组？]]></title>
    <url>%2F2016%2F08%2F12%2F2016-08-12-fake-array%2F</url>
    <content type="text"><![CDATA[万物皆为一物。 我们经常可以从各种库或框架中拿到这样的值： 明明是一个对象，却有length属性；或者明明看上去是个数组，却不能使用数组的方法（arguments）。我们今天就来聊聊怎么伪造数组。 有时，我们想创建一个包含数组数据的对象，如果仅仅是集合，只要使用数组就行。但很多时候，我们还要保存一些与集合相关的元数据。 我们可以给普通对象添加一些我们想要的功能，让它看起来像一个数组吗？Array的原型链上有很多处理集合的方法，我们可以把这些方法嫁接到自己的对象上吗？ 事实证明是可以的： 123456789101112131415161718var elems = &#123; length: 0, add: function(elem)&#123; Array.prototype.push.call(this, elem); &#125;, gather: function(id)&#123; this.add(document.getElementById(id)); &#125;&#125;;elems.gather("first"); elems.gather("second"); console.log(elems); 在这个例子中，我们给elems对象添加了一些模拟数组的行为，首先定义了length属性，用于保存元素个数。 之后定义了一个方法，用于将元素添加到模拟数组的结尾。我们使用了原生数组的方法：Array.prototype.push,而不是自己编写代码。 正常情况下，push方法是通过其函数上下文操作自身数组的，在这里我们用call方法强制用我们自己的对象作为push的函数上下文。 push函数会增加length属性，并给对象添加一个数字属性，再将其引用到传入的元素上。在某种程度上来说，这是颠覆性的！ add方法期望接收一个用于储存的元素引用，所以，我们为了方便，定义了gather方法，用于根据id值查找对应元素，并调用add方法将其添加到储存中。 我们打印出elems对象看一看： 这就是我们想要的！ 当然，这只是表面我们看到的，关于伪造数组，还有很多的知识要了解，这里只是告诉你它的基本实现，有兴趣了解更多的话，Google一下吧！ 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
        <tag>Object</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你把百度的关键字搜索偷过来用用]]></title>
    <url>%2F2016%2F07%2F01%2F2016-07-01-baidu-keywords%2F</url>
    <content type="text"><![CDATA[你真以为我偷东西啊！对啊，我就是偷东西。 话不多说，先上效果图。 怎么样，是不是和在用百度一下时，关键字搜索补全一样一样的。 今天下午没什么事，打开百度首页的Newwork看了一下，发现我每次输入内容后，它都会把我们输入的内容发送到后台，后台返回这些关键字的联想条目，我们只需要把这些条目放到页面中，就可以实现上图所示的demo了。 下面我们就来看看怎么获取这些内容。 先打开百度首页，我是用的chrome浏览器，F12，选到Network（你可能发现Network中是空的，刷新一下页面就好了）： 看到一大堆请求过来的文件，下面我们要找到关键的文件，也就是我们输入时，百度返回的文件，最快速的方法就是输入一大堆的字母，这样可以很方便的找到,我输入了一大堆的ssssss…..： 看到这些返回的文件吗，wd=ssssssssssss….，我们随便双击一条，把弹出窗口中的Request URL里的网址复制下来，这个就是我们完成关键字搜索的请求路径。 我们可以把网址直接复制到浏览器地址栏，看看得到的是个什么东西: 12345678910111213141516171819202122232425262728jQuery110204129574971066774_1467359127325(&#123;"q": "哈哈是什么yisi","p": true,"bs": "","csor": "9","g": [&#123;"q": "哈哈是什么意思","t": "n","st": &#123;"q": "哈哈是什么意思","new": 0&#125;&#125;,&#123;"q": "哈哈哈哈是什么意思","t": "n","st": &#123;"q": "哈哈哈哈是什么意思","new": 0&#125;&#125;],"s": ["哈哈是什么意思","哈哈哈哈是什么意思"]&#125;); 得到的数据是一个对象，不过对象被包裹在一个函数内，这个格式是不是很熟悉啊，对，就是jsonp！分析完这个数据格式，发现我们需要的是这个对象下的s数组里的数据，那我们就把s里的数据拿出来插入到页面中就行了，开始吧！ 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-2.1.0.js" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" onkeyup="require()" id="search"/&gt; &lt;div id="show"&gt;&lt;/div&gt; &lt;script&gt; //do something...... &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这段html代码很简单，引入了jQuery，一个输入框，一个承载返回内容的div，我么直接把script写在body的最下面，当我么输入时手指抬起，就去调用require函数，这个函数里就是我们的关键代码。（大家可以想想为什么要用onkeyup，这是个坑） 1234567891011121314151617181920function require()&#123; var search = $("#search").val(); var _url = 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+search+'&amp;json=1&amp;p=3&amp;sid=20144_1467_19033_20515_18240_17949_20388_20456_18133_17001_15202_11615&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery110207612423721154653_1467355506619&amp;_=1467355506623'; $.ajax(&#123; type:"get", url:_url, async:true, dataType:'jsonp', jsonpCallback:'jQuery110207612423721154653_1467355506619', success:function(data)&#123; console.log(data); var list = data.s; var str =""; for(var i in list)&#123; str+='&lt;p&gt;'+list[i]+'&lt;/p&gt;'; &#125; $("#show").html(str); &#125; &#125;);&#125; 当require函数被触发时，执行以上代码，我们来分析一下上面的代码。 先获取到输入框的内容，再定义一个_url，把我们之前得到的url地址附给这个变量，但是注意要把关键字的值改成输入框内的值，这样才能动态获取，不然你一直都在请求一个固定的关键字（上面把_url中的search标红加粗了）。 准备工作做好，可以发起ajax请求了，因为是jsonp的格式，所以要设置dataType:’jsonp’，并告诉jQuery回调函数的名称，这个名称可以在浏览器中得到（之前在浏览器地址栏输入url，得到的数据被包含在一个函数里，这里的jsonpCallback就写那个函数的名称，每个人的都不一样）。 现在我们只需要把数据console.log出来，并解析到页面上，就可以实现文章开头的效果了，简单吧！(记得放在服务器环境运行哦！) 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JSONP</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起来花5分钟写一个PHP入门Demo]]></title>
    <url>%2F2016%2F06%2F28%2F2016-06-28-php-demo%2F</url>
    <content type="text"><![CDATA[你以为很难，只是因为你没有去行动。 最近公司招了几个应届毕业生，他们对前端的了解还挺多，但是对后端的技术一无所知，我觉得，作为一个前端攻城狮，如果你有远大的抱负，就应该雨露均沾… 今天我就跟大家讲一讲PHP最基本的入门，至少别人问起你来，不会一点都不懂。 大家知道PHP搭建环境蛮麻烦的，咱们前端攻城狮就没必要去钻研环境的搭建了，网上已经有集成好的PHP环境可以直接下载，wamp和phpstudy，安装只需下一步就行。 因为我一直是使用wamp，以下就以wamp为例来讲解。（我安装的是wamp5） 安装好wamp后，屏幕右下角会出现这个图标。 如果你英语不是很好的话，可以右击图标，选择中文。 wamp打开后会默认开启所有服务，你也可以左击图标，选择启动所有服务，并且切换到在线状态。 到此，PHP运行的环境就准备好了。 下面开始写demo了。 点击右下角小图标，有个www目录，进入后创建一个叫PHP的项目文件夹： 在文件夹中新建这几个文件： 我们先打开login.html，写入一个简单的表单： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="success.php" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br/&gt;&lt;br/&gt; 密码：&lt;input type="password" name="pwd"&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="submit" name="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 我们需要实现用户点击提交时，把用户输入的用户名和密码保存在本地的data.txt文件里，并且在success.php页面提示用户登录成功。 下面我们开始关键的php代码，打开success.php文件，敲入以下代码： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $name = $_POST["username"]; $pwd = $_POST["pwd"]; $fp = fopen("./data.txt", "a"); $str = "user:".$name."&amp;password:".$pwd."\r\n"; fwrite($fp,$str); fclose($fp); echo "&lt;h1&gt;欢迎回来,".$name."！&lt;/h1&gt;"; ?&gt;&lt;/body&gt;&lt;/html&gt; 大家要注意，PHP代码可以和HTML代码混合使用，包裹在&lt;?php doSomething ?&gt;标签内的代码，服务器就会用PHP的解析器去解析，我们来分析一下上面的代码。 因为表单使用post方式提交的，所以我们需要用POST方式去接收，PHP接收POST发送过来的数据使用$_POST[&quot;&quot;];语句，get用法一样，把POST改成GET，在中括号内填写你需要获取表单项的name名。 接下来我们要把所得到的数据写入到data.txt文件内，实际项目开发中，这些数据都是写入到数据库中。 我们用fopen命令打开一个文件，fopen接收两个参数，第一个是要打开文件的路径；第二个是打开的方式，这里使用a写入方式打开，将文件指针指向文件末尾，如果文件不存在，则会尝试创建这个文件。（其他参数详情请到W3school查看） 还需要注意的是，PHP中的变量声明并不是用var，而是$+变量名。 接下来把用户名和密码拼接成字符串，PHP中的字符串拼接和JavaScript也有差异，PHP使用.来做拼接符。 我们用fwrite命令来写入文件，它接收两个参数，第一个是要打开的文件，也就是我们前面定义的$fp；第二个是要写入的内容，把之前拼接好的字符串放入。 最后还需要关闭文件，使用fclose命令，传入需要关闭的文件。如果不关闭文件的话，这个文件就会一直被占用，别人就不能读写这个文件了，所以这一步千万不能忘记。 最后，我么在success.php页面输出一条消息，JavaScript中可以用document.write来输出内容，PHP使用echo语句来输出内容，支持输入HTML标签。 到此，一个简单的PHP_Demo就写好了，我们来测试一下吧。 在浏览器输入http://localhost/php/login.html进入页面，我们随便输入一些信息： 提交后，页面跳转到success.php，我们看到如下内容： 我们打开data.txt文件，看看数据是否被写入了。 的确按照我们规定的格式写入了数据，我来多登录几次试试： 测试成功！ 希望大家跟着上面的代码敲一遍，你会发现挺有成就感的，至少我最初学习PHP完成这个Demo时，兴奋坏了我。 当然，这只是PHP最简单的一些实例，过段时间再写篇如何用PHP操作MySQL读写数据的文章，希望大家对技术保持一颗好奇心，这样才能真正成长！ 最后附上项目源码:EasyPHP(还是希望大家能敲一下) 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自网易云音乐的脑洞，带尖角的div......]]></title>
    <url>%2F2016%2F06%2F22%2F2016-06-22-music-cloud%2F</url>
    <content type="text"><![CDATA[很多时候最不能相信的就是你的眼睛。 今天在网易云的网页版听歌，话说Steve Vai的曲子永远是这么让人揣摩不透，不过我还时更喜欢老Joe，咦，跑题了··· 大家可以看到评论输入框和回复框，上面都有个小尖角，实现的方式有很多，我一般是用border来做，只要给一个元素加上这四条属性就行了： 1234border-top: 400px solid red;border-right: 400px solid transparent;border-bottom: 400px solid transparent;border-left: 400px solid transparent; 下面要讲的是网易云上面的黑科技，我看完真的是服··· 作为一个程序猿，看网页总喜欢手贱的审查元素… 咦？这两个小黑块是啥？稍微一想，原来是这样…. 顶层的小方块颜色是白色背景颜色，下面还层叠了一个背景颜色为边框颜色的小方块，还是上图比较直观： 这里有两个小方块，我们两个小方块都position:absolute;把右边的小方块向左移，移到马上覆盖左边方块为止： OK，就像这个样子，聪明的你可能已经知道这个是什么了，假定背景颜色是白色的，边框是红色的，那我们只需要改变着两个元素的color属性即可： 我们只需给父元素position:relative;把这两个小方块定位到相应的地方就OK啦，感觉能想到这种方法的人也挺牛的，啊哈。 本文作者：余震（Shock）本文出处：Rockjins Blog版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>